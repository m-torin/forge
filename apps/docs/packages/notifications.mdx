---
title: "Notifications Package"
sidebarTitle: "Notifications"
description:
  "Multi-channel notification system with Mantine UI integration and Knock.io
  backend"
icon: "bell"
---

# Notifications Package

Multi-channel notification system combining **Mantine UI notifications** for
instant feedback with **Knock.io** for comprehensive notification delivery
(email, SMS, push, in-app).

## Overview

The notifications package provides a complete notification solution featuring:

- **Instant UI Feedback**: Mantine-based toast notifications with styled presets
- **Multi-Channel Delivery**: Knock.io integration for email, SMS, push
  notifications
- **Real-Time Feeds**: In-app notification feeds with React components
- **Graceful Degradation**: Works without configuration for development
- **Environment-Aware**: Smart defaults that adapt to dev/prod environments

## Key Features

<CardGroup cols={2}>
  <Card title="Mantine Integration" icon="sparkles">
    Beautiful toast notifications with customizable themes and animations
  </Card>
  <Card title="Knock.io Backend" icon="cloud">
    Professional notification delivery with templates and user preferences
  </Card>
  <Card title="Real-Time Feeds" icon="feed">
    Live notification feeds with mark as read and infinite scroll
  </Card>
  <Card title="Edge Compatible" icon="zap">
    Works in serverless and edge environments
  </Card>
</CardGroup>

## Installation

```bash
pnpm add @repo/notifications
```

## Quick Start

### Basic Usage

<Tabs>
  <Tab title="Next.js Client Components">
    ```typescript
    'use client';

    import { notify } from '@repo/notifications/mantine-notifications';

    export function MyComponent() {
      const handleSuccess = () => {
        notify.success('Data saved successfully!');
      };

      const handleError = () => {
        notify.error('Something went wrong');
      };

      return (
        <div>
          <button onClick={handleSuccess}>Save</button>
          <button onClick={handleError}>Error</button>
        </div>
      );
    }
    ```

  </Tab>

  <Tab title="Server Actions">
    ```typescript
    'use server';

    import { knock } from '@repo/notifications/server/next';

    export async function processOrder(orderId: string, userId: string) {
      try {
        // Process order logic...

        // Send notification via Knock
        await knock.notify('order-confirmed', {
          recipients: [userId],
          data: {
            orderId,
            orderTotal: '$99.99',
            estimatedDelivery: '3-5 business days'
          }
        });

        return { success: true };
      } catch (error) {
        await knock.notify('order-failed', {
          recipients: [userId],
          data: { orderId, error: error.message }
        });

        throw error;
      }
    }
    ```

  </Tab>
</Tabs>

### Setup Required Components

```typescript
// app/layout.tsx
import { Notifications } from '@mantine/notifications';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <MantineProvider>
          {children}
          <Notifications />
        </MantineProvider>
      </body>
    </html>
  );
}
```

## Configuration

### Environment Variables

```bash
# Knock.io Configuration (Optional - falls back to console logging)
KNOCK_API_KEY="sk_test_..."
KNOCK_SIGNING_KEY="sk_signing_..."

# Default notification settings
NOTIFICATIONS_DEFAULT_FROM="notifications@yourapp.com"
NOTIFICATIONS_APP_NAME="Your App Name"
```

### Mantine Theme Integration

```typescript
// Configure notification styles in your Mantine theme
import type { MantineThemeOverride } from "@mantine/core";

export const theme: MantineThemeOverride = {
  components: {
    Notification: {
      styles: {
        root: {
          borderRadius: "8px"
        },
        title: {
          fontWeight: 600
        }
      }
    }
  }
};
```

## UI Notifications (Mantine)

### Basic Notification Methods

<AccordionGroup>
  <Accordion title="Success Notifications" icon="check">
    ```typescript
    import { notify } from '@repo/notifications/mantine-notifications';

    // Simple success
    notify.success('Data saved successfully');

    // Success with custom options
    notify.success('Profile updated', {
      title: 'Success',
      autoClose: 3000,
    });

    // Success with action
    notify.success('File uploaded', {
      title: 'Upload Complete',
      message: 'Click to view file',
      onClick: () => window.open('/files/document.pdf')
    });
    ```

  </Accordion>

  <Accordion title="Error Notifications" icon="x">
    ```typescript
    // Simple error
    notify.error('Failed to save data');

    // Error with details
    notify.error('Validation failed', {
      title: 'Form Error',
      message: 'Please check the required fields'
    });

    // Error with retry action
    notify.error('Network error', {
      title: 'Connection Failed',
      message: 'Click to retry',
      onClick: () => retryOperation(),
      autoClose: false // Keep open until dismissed
    });
    ```

  </Accordion>

  <Accordion title="Info & Warning" icon="info">
    ```typescript
    // Info notification
    notify.info('New features available', {
      title: 'Update Available',
      message: 'Click to learn more'
    });

    // Warning notification
    notify.warning('Unsaved changes', {
      title: 'Warning',
      message: 'You have unsaved changes that will be lost'
    });

    // Loading notification
    const id = notify.loading('Processing...');

    // Update the loading notification
    setTimeout(() => {
      notify.update(id, {
        message: 'Complete!',
        color: 'green',
        loading: false,
        autoClose: 2000
      });
    }, 3000);
    ```

  </Accordion>
</AccordionGroup>

### Advanced UI Features

<AccordionGroup>
  <Accordion title="Custom Styling" icon="paintbrush">
    ```typescript
    import { notify } from '@repo/notifications/mantine-notifications';

    // Custom colors and icons
    notify.show({
      message: 'Custom notification',
      color: 'grape',
      icon: 'ðŸŽ‰',
      autoClose: 5000
    });

    // With custom styles
    notify.show({
      message: 'Styled notification',
      styles: {
        root: {
          backgroundColor: 'var(--mantine-color-blue-6)',
          borderColor: 'var(--mantine-color-blue-6)',
        },
        title: { color: 'white' },
        description: { color: 'white' },
        closeButton: { color: 'white' }
      }
    });
    ```

  </Accordion>

  <Accordion title="Notification Management" icon="settings">
    ```typescript
    // Hide all notifications
    notify.clean();

    // Hide specific notification
    const id = notify.show({ message: 'Will be hidden' });
    notify.hide(id);

    // Update existing notification
    notify.update(id, {
      message: 'Updated message',
      color: 'green'
    });

    // Queue multiple notifications
    notify.show({ message: 'First' });
    notify.show({ message: 'Second' });
    notify.show({ message: 'Third' });
    ```

  </Accordion>

  <Accordion title="Interactive Notifications" icon="cursor-click">
    ```typescript
    // Confirmation notification
    notify.show({
      title: 'Delete Item',
      message: 'Are you sure you want to delete this item?',
      color: 'red',
      actions: [
        {
          label: 'Delete',
          onClick: () => deleteItem(),
          color: 'red'
        },
        {
          label: 'Cancel',
          onClick: () => notify.clean()
        }
      ],
      autoClose: false
    });

    // Progress notification
    let progress = 0;
    const id = notify.show({
      message: `Upload progress: ${progress}%`,
      loading: true,
      autoClose: false
    });

    const interval = setInterval(() => {
      progress += 10;
      notify.update(id, {
        message: `Upload progress: ${progress}%`,
        loading: progress < 100
      });

      if (progress >= 100) {
        clearInterval(interval);
        notify.update(id, {
          message: 'Upload complete!',
          color: 'green',
          autoClose: 2000
        });
      }
    }, 500);
    ```

  </Accordion>
</AccordionGroup>

## Multi-Channel Notifications (Knock.io)

### Server-Side Delivery

<AccordionGroup>
  <Accordion title="Basic Workflow Triggering" icon="play">
    ```typescript
    import { knock } from '@repo/notifications/server/next';

    // Trigger a workflow
    await knock.notify('welcome-series', {
      recipients: ['user_123'],
      data: {
        userName: 'John Doe',
        accountType: 'premium'
      }
    });

    // Trigger with multiple recipients
    await knock.notify('team-notification', {
      recipients: ['user_123', 'user_456'],
      data: {
        projectName: 'New Project',
        message: 'You have been added to a new project'
      }
    });

    // Trigger with actor (who performed the action)
    await knock.notify('comment-notification', {
      recipients: ['post_author_id'],
      actor: 'commenter_user_id',
      data: {
        postTitle: 'My Blog Post',
        commentText: 'Great article!'
      }
    });
    ```

  </Accordion>

  <Accordion title="User Preferences" icon="user-gear">
    ```typescript
    // Set user notification preferences
    await knock.users.setPreferences('user_123', {
      workflows: {
        'welcome-series': {
          channel_types: { email: true, sms: false }
        },
        'marketing-updates': {
          channel_types: { email: false, push: false }
        }
      }
    });

    // Get user preferences
    const preferences = await knock.users.getPreferences('user_123');
    console.log(preferences);

    // Update user profile
    await knock.users.identify('user_123', {
      name: 'John Doe',
      email: 'john@example.com',
      phone_number: '+1234567890',
      timezone: 'America/New_York'
    });
    ```

  </Accordion>

  <Accordion title="Bulk Operations" icon="list">
    ```typescript
    // Bulk trigger notifications
    await knock.workflows.trigger('daily-digest', {
      recipients: [
        { id: 'user_1', email: 'user1@example.com' },
        { id: 'user_2', email: 'user2@example.com' }
      ],
      data: {
        digest_date: new Date().toISOString(),
        unread_count: 5
      }
    });

    // Cancel bulk operation
    await knock.workflows.cancel('daily-digest', {
      recipients: ['user_1', 'user_2']
    });
    ```

  </Accordion>
</AccordionGroup>

### In-App Notification Feeds

<AccordionGroup>
  <Accordion title="Feed Integration" icon="feed">
    ```typescript
    // components/NotificationFeed.tsx
    'use client';

    import { useKnockFeed } from '@knocklabs/react';
    import { useEffect } from 'react';

    export function NotificationFeed({ userId }: { userId: string }) {
      const { feedClient, items, metadata } = useKnockFeed(
        process.env.NEXT_PUBLIC_KNOCK_PUBLIC_API_KEY!,
        userId,
        process.env.NEXT_PUBLIC_KNOCK_FEED_ID!
      );

      useEffect(() => {
        // Mark all as read when component mounts
        feedClient?.markAllAsRead();
      }, [feedClient]);

      return (
        <div className="notification-feed">
          {items.map((item) => (
            <div key={item.id} className="notification-item">
              <div className="notification-content">
                <h4>{item.blocks?.[0]?.rendered}</h4>
                <p>{item.blocks?.[1]?.rendered}</p>
                <span className="timestamp">
                  {new Date(item.inserted_at).toLocaleDateString()}
                </span>
              </div>
              {!item.read_at && (
                <button
                  onClick={() => feedClient?.markAsRead(item)}
                  className="mark-read-btn"
                >
                  Mark as read
                </button>
              )}
            </div>
          ))}

          {metadata?.total_count === 0 && (
            <p className="no-notifications">No notifications yet</p>
          )}
        </div>
      );
    }
    ```

  </Accordion>

  <Accordion title="Real-time Updates" icon="bolt">
    ```typescript
    // Real-time notification updates
    import { useKnockFeed } from '@knocklabs/react';
    import { useEffect } from 'react';

    export function LiveNotificationBadge({ userId }: { userId: string }) {
      const { feedClient, metadata } = useKnockFeed(
        process.env.NEXT_PUBLIC_KNOCK_PUBLIC_API_KEY!,
        userId,
        process.env.NEXT_PUBLIC_KNOCK_FEED_ID!,
        {
          auto_manage_socket_connection: true // Enable real-time updates
        }
      );

      const unreadCount = metadata?.unread_count || 0;

      return (
        <div className="notification-badge">
          ðŸ””
          {unreadCount > 0 && (
            <span className="badge-count">{unreadCount}</span>
          )}
        </div>
      );
    }
    ```

  </Accordion>

  <Accordion title="Custom Feed Renderer" icon="code">
    ```typescript
    import { NotificationFeedPopover, NotificationIconButton } from '@knocklabs/react';

    export function CustomNotificationFeed({ userId }: { userId: string }) {
      return (
        <NotificationFeedPopover
          apiKey={process.env.NEXT_PUBLIC_KNOCK_PUBLIC_API_KEY!}
          userId={userId}
          feedId={process.env.NEXT_PUBLIC_KNOCK_FEED_ID!}
          renderItem={({ item, ...props }) => (
            <div className="custom-notification-item" {...props}>
              <div className="notification-avatar">
                {item.actors?.[0]?.avatar || 'ðŸ‘¤'}
              </div>
              <div className="notification-body">
                <p>{item.blocks?.[0]?.rendered}</p>
                <span className="time-ago">
                  {formatTimeAgo(item.inserted_at)}
                </span>
              </div>
              {!item.read_at && <div className="unread-indicator" />}
            </div>
          )}
        >
          <NotificationIconButton />
        </NotificationFeedPopover>
      );
    }

    function formatTimeAgo(date: string): string {
      const now = new Date();
      const past = new Date(date);
      const diffMs = now.getTime() - past.getTime();
      const diffMins = Math.floor(diffMs / 60000);

      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffMins < 1440) return `${Math.floor(diffMins / 60)}h ago`;
      return `${Math.floor(diffMins / 1440)}d ago`;
    }
    ```

  </Accordion>
</AccordionGroup>

## Workflow Templates

### Common Notification Patterns

<AccordionGroup>
  <Accordion title="Authentication Flows" icon="shield-check">
    ```typescript
    // Welcome new user
    await knock.notify('user-welcome', {
      recipients: [userId],
      data: {
        userName: user.name,
        verificationLink: `${baseUrl}/verify?token=${token}`,
        dashboardUrl: `${baseUrl}/dashboard`
      }
    });

    // Password reset
    await knock.notify('password-reset', {
      recipients: [userId],
      data: {
        resetLink: `${baseUrl}/reset-password?token=${resetToken}`,
        expiresIn: '1 hour',
        ipAddress: request.ip
      }
    });

    // Login from new device
    await knock.notify('security-alert', {
      recipients: [userId],
      data: {
        deviceInfo: request.headers['user-agent'],
        location: await getLocationFromIP(request.ip),
        timestamp: new Date().toISOString()
      }
    });
    ```

  </Accordion>

  <Accordion title="Team Collaboration" icon="users">
    ```typescript
    // Team invitation
    await knock.notify('team-invite', {
      recipients: [inviteeEmail],
      actor: inviterId,
      data: {
        teamName: 'Engineering Team',
        inviterName: inviter.name,
        joinLink: `${baseUrl}/join?token=${inviteToken}`,
        role: 'developer'
      }
    });

    // Project updates
    await knock.notify('project-update', {
      recipients: teamMemberIds,
      actor: updaterId,
      data: {
        projectName: 'Mobile App Redesign',
        updateType: 'milestone_completed',
        milestone: 'User Interface Design',
        nextSteps: 'Ready for development review'
      }
    });

    // Task assignment
    await knock.notify('task-assigned', {
      recipients: [assigneeId],
      actor: assignerId,
      data: {
        taskTitle: 'Implement user authentication',
        projectName: 'Web Portal',
        dueDate: '2024-02-15',
        priority: 'high',
        taskUrl: `${baseUrl}/tasks/${taskId}`
      }
    });
    ```

  </Accordion>

  <Accordion title="System Events" icon="gear">
    ```typescript
    // Maintenance notifications
    await knock.notify('maintenance-alert', {
      recipients: allActiveUserIds,
      data: {
        maintenanceStart: '2024-02-10T02:00:00Z',
        maintenanceEnd: '2024-02-10T04:00:00Z',
        expectedDowntime: '2 hours',
        affectedServices: ['API', 'Dashboard', 'Mobile App']
      }
    });

    // Billing notifications
    await knock.notify('payment-failed', {
      recipients: [accountOwnerId],
      data: {
        planName: 'Pro Plan',
        amount: '$29.99',
        cardLast4: '4242',
        retryDate: '2024-02-12',
        updateBillingUrl: `${baseUrl}/billing`
      }
    });

    // Usage alerts
    await knock.notify('usage-limit-warning', {
      recipients: [accountOwnerId],
      data: {
        resourceType: 'API Calls',
        currentUsage: 8500,
        monthlyLimit: 10000,
        percentUsed: 85,
        upgradeUrl: `${baseUrl}/upgrade`
      }
    });
    ```

  </Accordion>
</AccordionGroup>

## Error Handling & Fallbacks

### Graceful Degradation

<AccordionGroup>
  <Accordion title="Environment-Aware Behavior" icon="shield">
    ```typescript
    // The package automatically handles missing configuration
    import { knock } from '@repo/notifications/server/next';

    try {
      await knock.notify('user-signup', {
        recipients: [userId],
        data: { userName: 'John' }
      });
    } catch (error) {
      // In development: logs to console
      // In production: logs error but doesn't throw
      console.log('Notification fallback triggered');
    }

    // Manual fallback handling
    export async function sendNotificationWithFallback(
      workflowId: string,
      options: any
    ) {
      try {
        await knock.notify(workflowId, options);
      } catch (error) {
        // Log to monitoring service
        console.error('Knock notification failed:', error);

        // Fallback to email service
        await sendFallbackEmail(options.recipients, options.data);
      }
    }
    ```

  </Accordion>

  <Accordion title="Retry Logic" icon="refresh">
    ```typescript
    export async function sendNotificationWithRetry(
      workflowId: string,
      options: any,
      maxRetries = 3
    ) {
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          await knock.notify(workflowId, options);
          return; // Success
        } catch (error) {
          console.error(`Notification attempt ${attempt} failed:`, error);

          if (attempt === maxRetries) {
            // Final attempt failed, use fallback
            await handleNotificationFailure(workflowId, options, error);
            return;
          }

          // Exponential backoff
          await new Promise(resolve =>
            setTimeout(resolve, Math.pow(2, attempt) * 1000)
          );
        }
      }
    }

    async function handleNotificationFailure(
      workflowId: string,
      options: any,
      error: Error
    ) {
      // Log to error tracking service
      console.error('All notification attempts failed:', {
        workflowId,
        recipients: options.recipients,
        error: error.message
      });

      // Queue for later retry or manual intervention
      await queueFailedNotification({ workflowId, options, error });
    }
    ```

  </Accordion>
</AccordionGroup>

## Testing

### Mock Services

<AccordionGroup>
  <Accordion title="Development Mocks" icon="flask">
    ```typescript
    // Automatic mocking in test environment
    import { knock } from '@repo/notifications/server/next';

    // In test environment, this logs to console instead of calling Knock API
    await knock.notify('test-workflow', {
      recipients: ['user_123'],
      data: { message: 'Test notification' }
    });

    // Manual mock for testing
    const mockKnock = {
      notify: jest.fn().mockResolvedValue({ success: true }),
      users: {
        identify: jest.fn().mockResolvedValue({}),
        setPreferences: jest.fn().mockResolvedValue({})
      }
    };

    // Use in tests
    jest.mock('@repo/notifications/server/next', () => ({
      knock: mockKnock
    }));
    ```

  </Accordion>

  <Accordion title="E2E Testing" icon="robot">
    ```typescript
    // Test notification delivery end-to-end
    import { test, expect } from '@playwright/test';

    test('user receives welcome notification', async ({ page, context }) => {
      // Sign up new user
      await page.goto('/signup');
      await page.fill('[data-testid="email"]', 'test@example.com');
      await page.click('[data-testid="signup-btn"]');

      // Check for success notification in UI
      await expect(page.locator('.mantine-Notification-root')).toContainText(
        'Welcome! Please check your email.'
      );

      // Verify notification appears in feed (if using in-app notifications)
      await page.click('[data-testid="notification-bell"]');
      await expect(
        page.locator('[data-testid="notification-item"]').first()
      ).toContainText('Welcome to our platform');
    });
    ```

  </Accordion>

  <Accordion title="Unit Testing" icon="code">
    ```typescript
    import { notify } from '@repo/notifications/mantine-notifications';
    import { render, screen, fireEvent } from '@testing-library/react';
    import { MantineProvider, Notifications } from '@mantine/core';

    function TestComponent() {
      return (
        <button
          onClick={() => notify.success('Test notification')}
          data-testid="trigger-notification"
        >
          Trigger
        </button>
      );
    }

    test('shows success notification', async () => {
      render(
        <MantineProvider>
          <TestComponent />
          <Notifications />
        </MantineProvider>
      );

      fireEvent.click(screen.getByTestId('trigger-notification'));

      expect(await screen.findByText('Test notification')).toBeInTheDocument();
    });
    ```

  </Accordion>
</AccordionGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="User Experience" icon="heart">
    - **Progressive Enhancement**: Start with basic UI notifications, add channels as needed
    - **Respectful Timing**: Don't overwhelm users with too many notifications
    - **Clear Actions**: Make notification actions obvious and accessible
    - **Preference Control**: Always provide ways for users to control notification preferences
    - **Contextual Relevance**: Send notifications that are relevant to the user's current context
  </Accordion>

<Accordion title="Performance" icon="zap">
  - **Async Processing**: Never block user interactions for notification
  delivery - **Batch Operations**: Group related notifications to reduce API
  calls - **Smart Queuing**: Queue notifications during high-traffic periods -
  **Error Boundaries**: Wrap notification components in error boundaries -
  **Memory Management**: Clean up notification listeners and subscriptions
</Accordion>

<Accordion title="Security" icon="shield">
  - **Data Sanitization**: Sanitize all user-generated content in notifications
  - **Permission Checks**: Verify user permissions before sending notifications
  - **Rate Limiting**: Implement rate limiting to prevent notification spam -
  **Audit Logging**: Log all notification activities for security monitoring -
  **Secure Templates**: Use secure templating to prevent XSS in notification
  content
</Accordion>

  <Accordion title="Monitoring" icon="chart-line">
    - **Delivery Tracking**: Monitor notification delivery rates and failures
    - **User Engagement**: Track notification open rates and click-through rates
    - **Performance Metrics**: Monitor notification rendering and API response times
    - **Error Monitoring**: Set up alerts for notification service failures
    - **A/B Testing**: Test different notification templates and timing strategies
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Common Issues" icon="question-circle">
    **Notifications not appearing:**
    - Verify `<Notifications />` component is rendered in your app
    - Check browser console for JavaScript errors
    - Ensure Mantine theme is properly configured

    **Knock.io notifications not sending:**
    - Verify `KNOCK_API_KEY` environment variable is set
    - Check workflow is published in Knock dashboard
    - Verify recipient IDs match user identifiers in Knock

    **Real-time updates not working:**
    - Ensure WebSocket connections are not blocked by firewall
    - Check `NEXT_PUBLIC_KNOCK_PUBLIC_API_KEY` is set for client-side usage
    - Verify feed ID matches the configured feed in Knock dashboard

  </Accordion>

  <Accordion title="Debug Mode" icon="bug">
    ```typescript
    // Enable debug logging for notifications
    import { knock } from '@repo/notifications/server/next';

    // Add debug flag to see detailed logs
    await knock.notify('debug-workflow', {
      recipients: ['user_123'],
      data: { debug: true },
      __debug: true // Internal debug flag
    });

    // Client-side debugging
    import { notify } from '@repo/notifications/mantine-notifications';

    // Log notification events
    notify.show({
      message: 'Debug notification',
      onOpen: () => console.log('Notification opened'),
      onClose: () => console.log('Notification closed')
    });
    ```

  </Accordion>
</AccordionGroup>
