---
title: "Prisma ORM (PostgreSQL)"
description:
  "Primary database with authentication and organization management using Prisma
  ORM and PostgreSQL"
icon: "database"
---

# Prisma ORM (PostgreSQL)

Primary database provider using Prisma ORM with PostgreSQL for authentication,
user management, and organization features.

## Overview

Prisma serves as the primary database layer for authentication and user
management in the Forge platform, providing type-safe database access with a
comprehensive schema covering authentication, organizations, teams, and security
features.

<CardGroup cols={2}>
  <Card title="Better Auth Integration" icon="users">
    Complete user management, organizations, API keys, and sessions
  </Card>
  <Card title="Team Management" icon="building">
    Organization, team, and member management with role-based access
  </Card>
  <Card title="Security Features" icon="shield-check">
    Two-factor authentication, passkeys, backup codes, and API key management
  </Card>
  <Card title="Type Safety" icon="shield-check">
    Full TypeScript integration with generated types
  </Card>
</CardGroup>

## Quick Start

```typescript
import { prisma } from "@repo/database/prisma";
import { logInfo } from "@repo/observability/server/next";

// Basic user query
const users = await prisma.user.findMany({
  include: {
    organizations: true,
    sessions: true
  }
});

// Create a new organization
const org = await prisma.organization.create({
  data: {
    name: "Acme Corp",
    slug: "acme-corp",
    members: {
      create: {
        userId: userId,
        role: "owner"
      }
    }
  }
});
```

## Schema Overview

### Authentication & User Management

<AccordionGroup>
  <Accordion title="User Management" icon="user">
    ```typescript
    // Create user with Better Auth integration
    const user = await prisma.user.create({
      data: {
        id: 'user_123',
        name: 'John Doe',
        email: 'john@example.com',
        emailVerified: true,
        role: 'user',
        preferences: {
          theme: 'dark',
          notifications: true
        }
      },
    });

    // User with organization membership
    const userWithOrgs = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        accounts: true,
        sessions: true,
        members: {
          include: {
            organization: true,
          },
        },
        apiKeys: true,
        twoFactor: true,
        passkeys: true
      },
    });

    // Soft delete user
    await prisma.user.update({
      where: { id: userId },
      data: {
        deletedAt: new Date(),
        email: `deleted_${Date.now()}@example.com` // Ensure unique constraint
      }
    });
    ```

  </Accordion>

  <Accordion title="Session Management" icon="clock">
    ```typescript
    // Create user session
    const session = await prisma.session.create({
      data: {
        id: 'session_123',
        userId: user.id,
        token: 'secure_session_token',
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
        ipAddress: '192.168.1.1',
        userAgent: 'Mozilla/5.0...',
        activeOrganizationId: organization.id
      }
    });

    // Get active sessions for user
    const activeSessions = await prisma.session.findMany({
      where: {
        userId: user.id,
        expiresAt: {
          gt: new Date()
        }
      },
      include: {
        user: {
          select: {
            name: true,
            email: true
          }
        }
      }
    });

    // Admin impersonation
    await prisma.session.update({
      where: { id: sessionId },
      data: {
        impersonatedBy: adminUserId
      }
    });
    ```

  </Accordion>

  <Accordion title="Account Linking" icon="link">
    ```typescript
    // Link social account to user
    const account = await prisma.account.create({
      data: {
        id: 'account_123',
        accountId: 'google_12345',
        providerId: 'google',
        userId: user.id,
        accessToken: 'oauth_access_token',
        refreshToken: 'oauth_refresh_token',
        scope: 'email profile',
        accessTokenExpiresAt: new Date(Date.now() + 3600 * 1000)
      }
    });

    // Get all linked accounts for user
    const userAccounts = await prisma.account.findMany({
      where: { userId: user.id },
      select: {
        providerId: true,
        accountId: true,
        scope: true,
        accessTokenExpiresAt: true
      }
    });
    ```

  </Accordion>
</AccordionGroup>

### Organization & Team Management

<AccordionGroup>
  <Accordion title="Organization Management" icon="building">
    ```typescript
    // Create organization with initial member
    const organization = await prisma.organization.create({
      data: {
        id: 'org_123',
        name: 'Tech Startup Inc',
        slug: 'tech-startup',
        description: 'A cutting-edge tech company',
        metadata: {
          plan: 'enterprise',
          features: ['advanced-analytics', 'custom-branding'],
          billingEmail: 'billing@techstartup.com'
        },
        members: {
          create: {
            id: 'member_123',
            userId: ownerId,
            role: 'owner',
          },
        },
      },
    });

    // Add team members
    await prisma.member.create({
      data: {
        id: 'member_456',
        organizationId: organization.id,
        userId: newUserId,
        role: 'admin',
      },
    });

    // Organization analytics
    const orgStats = await prisma.organization.findUnique({
      where: { id: organizationId },
      include: {
        _count: {
          select: {
            members: true,
            teams: true,
            invitations: true
          }
        },
        members: {
          include: {
            user: {
              select: {
                name: true,
                email: true,
                createdAt: true
              }
            }
          }
        }
      }
    });
    ```

  </Accordion>

  <Accordion title="Team Management" icon="users">
    ```typescript
    // Create team within organization
    const team = await prisma.team.create({
      data: {
        id: 'team_123',
        name: 'Engineering Team',
        description: 'Core product development team',
        organizationId: organization.id,
        teamMembers: {
          create: [
            {
              userId: leaderId,
              role: 'lead'
            },
            {
              userId: developerId,
              role: 'member'
            }
          ]
        }
      }
    });

    // Add member to team
    await prisma.teamMember.create({
      data: {
        userId: newMemberId,
        teamId: team.id,
        role: 'member'
      }
    });

    // Get team with members
    const teamWithMembers = await prisma.team.findUnique({
      where: { id: team.id },
      include: {
        teamMembers: {
          include: {
            user: {
              select: {
                name: true,
                email: true
              }
            }
          }
        },
        organization: {
          select: {
            name: true,
            slug: true
          }
        }
      }
    });
    ```

  </Accordion>

  <Accordion title="Invitation Management" icon="mail">
    ```typescript
    // Send organization invitation
    const invitation = await prisma.invitation.create({
      data: {
        id: 'inv_123',
        email: 'newuser@example.com',
        organizationId: organization.id,
        invitedById: currentUserId,
        role: 'member',
        teamId: team.id, // Optional: invite to specific team
        status: 'pending',
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
      }
    });

    // Accept invitation
    await prisma.$transaction([
      // Create organization membership
      prisma.member.create({
        data: {
          id: 'member_789',
          userId: acceptingUserId,
          organizationId: invitation.organizationId,
          role: invitation.role
        }
      }),
      // Create team membership if specified
      ...(invitation.teamId ? [
        prisma.teamMember.create({
          data: {
            userId: acceptingUserId,
            teamId: invitation.teamId,
            role: 'member'
          }
        })
      ] : []),
      // Mark invitation as accepted
      prisma.invitation.update({
        where: { id: invitation.id },
        data: { status: 'accepted' }
      })
    ]);

    // Clean up expired invitations
    await prisma.invitation.deleteMany({
      where: {
        expiresAt: {
          lt: new Date()
        },
        status: 'pending'
      }
    });
    ```

  </Accordion>
</AccordionGroup>

### Security & API Management

<AccordionGroup>
  <Accordion title="API Key Management" icon="key">
    ```typescript
    // Create API key for organization
    const apiKey = await prisma.apiKey.create({
      data: {
        id: 'key_123',
        name: 'Production API Key',
        key: 'ak_' + generateSecureKey(),
        keyHash: hashKey('ak_' + generateSecureKey()),
        prefix: 'ak_',
        start: 'ak_1234',
        userId: userId,
        organizationId: organization.id,
        permissions: JSON.stringify(['read:products', 'write:products']),
        rateLimitEnabled: true,
        rateLimitMax: 1000,
        rateLimitTimeWindow: 3600, // 1 hour
        expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year
      },
    });

    // Validate and use API key
    const validKey = await prisma.apiKey.findFirst({
      where: {
        key: providedKey,
        enabled: true,
        expiresAt: {
          gt: new Date(),
        },
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      },
    });

    // Update usage statistics
    if (validKey) {
      await prisma.apiKey.update({
        where: { id: validKey.id },
        data: {
          lastUsedAt: new Date(),
          requestCount: {
            increment: 1
          },
          lastRequest: new Date()
        }
      });
    }
    ```

  </Accordion>

  <Accordion title="Two-Factor Authentication" icon="shield">
    ```typescript
    // Setup 2FA for user
    const twoFactor = await prisma.twoFactor.create({
      data: {
        id: '2fa_123',
        userId: user.id,
        secret: encryptedSecret,
        secretHash: hashSecret(secret),
        enabled: false, // User must verify first
        verified: false,
        backupCodes: {
          create: generateBackupCodes().map(code => ({
            id: `backup_${Math.random()}`,
            code: encryptCode(code),
            codeHash: hashCode(code),
            userId: user.id
          }))
        }
      }
    });

    // Verify 2FA setup
    await prisma.twoFactor.update({
      where: { id: twoFactor.id },
      data: {
        verified: true,
        enabled: true
      }
    });

    // Use backup code
    const backupCode = await prisma.backupCode.findFirst({
      where: {
        codeHash: hashCode(providedCode),
        userId: user.id,
        used: false
      }
    });

    if (backupCode) {
      await prisma.backupCode.update({
        where: { id: backupCode.id },
        data: {
          used: true,
          usedAt: new Date()
        }
      });
    }
    ```

  </Accordion>

  <Accordion title="Passkey Management" icon="fingerprint">
    ```typescript
    // Register new passkey
    const passkey = await prisma.passkey.create({
      data: {
        id: 'passkey_123',
        name: 'iPhone TouchID',
        userId: user.id,
        credentialId: 'credential_unique_id',
        publicKey: base64PublicKey,
        counter: 0,
        deviceType: 'platform',
        backedUp: true,
        transports: ['internal']
      }
    });

    // Authenticate with passkey
    const existingPasskey = await prisma.passkey.findUnique({
      where: { credentialId: providedCredentialId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });

    if (existingPasskey && verifySignature(existingPasskey.publicKey, signature)) {
      await prisma.passkey.update({
        where: { id: existingPasskey.id },
        data: {
          counter: newCounter,
          lastUsedAt: new Date()
        }
      });
    }

    // List user's passkeys
    const userPasskeys = await prisma.passkey.findMany({
      where: { userId: user.id },
      select: {
        id: true,
        name: true,
        deviceType: true,
        createdAt: true,
        lastUsedAt: true
      },
      orderBy: {
        lastUsedAt: 'desc'
      }
    });
    ```

  </Accordion>
</AccordionGroup>

### Audit Logging

<AccordionGroup>
  <Accordion title="Security Audit Trail" icon="list-check">
    ```typescript
    // Log authentication events
    await prisma.auditLog.create({
      data: {
        type: 'auth.sign_in',
        action: 'user_login_success',
        userId: user.id,
        email: user.email,
        ipAddress: request.ip,
        userAgent: request.headers['user-agent'],
        success: true,
        metadata: {
          method: '2fa',
          sessionId: session.id
        }
      }
    });

    // Log failed login attempt
    await prisma.auditLog.create({
      data: {
        type: 'auth.sign_in',
        action: 'user_login_failed',
        email: attemptedEmail,
        ipAddress: request.ip,
        userAgent: request.headers['user-agent'],
        success: false,
        errorMessage: 'Invalid credentials',
        metadata: {
          attempts: failedAttempts + 1
        }
      }
    });

    // Query audit logs for user
    const userAuditLogs = await prisma.auditLog.findMany({
      where: {
        userId: user.id,
        timestamp: {
          gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
        }
      },
      orderBy: {
        timestamp: 'desc'
      },
      take: 100
    });

    // Security monitoring - detect suspicious activity
    const suspiciousActivity = await prisma.auditLog.findMany({
      where: {
        type: 'auth.sign_in',
        success: false,
        timestamp: {
          gte: new Date(Date.now() - 60 * 60 * 1000) // Last hour
        }
      },
      select: {
        email: true,
        ipAddress: true
      }
    });
    ```

  </Accordion>
</AccordionGroup>

## Advanced Queries

### Complex Joins and Aggregations

<AccordionGroup>
  <Accordion title="User Analytics" icon="chart-line">
    ```typescript
    // User engagement analytics
    const userStats = await prisma.user.findMany({
      include: {
        _count: {
          select: {
            sessions: true,
            apiKeys: true,
            members: true
          },
        },
        sessions: {
          where: {
            createdAt: {
              gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // Last 30 days
            },
          },
          select: {
            createdAt: true,
            ipAddress: true
          },
        },
      },
    });

    // Organization membership analytics
    const orgAnalytics = await prisma.organization.findUnique({
      where: { id: organizationId },
      include: {
        _count: {
          select: {
            members: true,
            teams: true,
            invitations: true
          },
        },
        members: {
          include: {
            user: {
              select: {
                name: true,
                email: true,
                createdAt: true
              }
            }
          },
          orderBy: {
            createdAt: 'desc'
          },
          take: 10 // Most recent members
        },
      },
    });
    ```

  </Accordion>

  <Accordion title="Performance Optimization" icon="gauge">
    ```typescript
    // Optimized queries with proper indexing
    const recentActivity = await prisma.$queryRaw`
      SELECT
        u.id,
        u.name,
        u.email,
        COUNT(s.id) as session_count,
        MAX(s.created_at) as last_login
      FROM "user" u
      LEFT JOIN session s ON u.id = s.user_id
      WHERE s.created_at >= NOW() - INTERVAL '7 days'
      GROUP BY u.id, u.name, u.email
      ORDER BY session_count DESC
      LIMIT 20
    `;

    // Batch operations for better performance
    const batchUpdate = await prisma.$transaction([
      // Clean up expired sessions
      prisma.session.deleteMany({
        where: {
          expiresAt: {
            lt: new Date()
          }
        }
      }),
      // Clean up old audit logs
      prisma.auditLog.deleteMany({
        where: {
          timestamp: {
            lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) // 90 days
          }
        }
      }),
      // Update user last activity
      prisma.user.updateMany({
        where: {
          sessions: {
            some: {
              createdAt: {
                gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
              }
            }
          }
        },
        data: {
          updatedAt: new Date()
        }
      })
    ]);
    ```

  </Accordion>
</AccordionGroup>

## Database Operations

### Migrations and Schema

<CodeGroup>
```bash Migration Commands
# Create a new migration
npx prisma migrate dev --name add_user_preferences

# Apply migrations in production

npx prisma migrate deploy

# Reset database (development only)

npx prisma migrate reset

# Check migration status

npx prisma migrate status

````

```bash Schema Management
# Generate Prisma client
npx prisma generate

# Format schema file
npx prisma format

# Validate schema
npx prisma validate

# View database in browser
npx prisma studio
````

</CodeGroup>

### Data Seeding

```typescript
// prisma/seed.ts
import { prisma } from "../src/prisma";
import { logInfo, logError } from "@repo/observability/server/next";

async function main() {
  // Create sample organization
  const org = await prisma.organization.upsert({
    where: { slug: "demo-org" },
    update: {},
    create: {
      id: "org_demo",
      name: "Demo Organization",
      slug: "demo-org",
      description: "A demo organization for testing"
    }
  });

  // Create sample user
  const user = await prisma.user.upsert({
    where: { email: "admin@demo.com" },
    update: {},
    create: {
      id: "user_admin",
      name: "Admin User",
      email: "admin@demo.com",
      emailVerified: true,
      role: "admin",
      members: {
        create: {
          id: "member_admin",
          organizationId: org.id,
          role: "owner"
        }
      }
    }
  });

  // Create sample API key
  await prisma.apiKey.create({
    data: {
      id: "key_demo",
      name: "Demo API Key",
      key: "ak_demo_key_123",
      keyHash: "hashed_demo_key",
      prefix: "ak_",
      start: "ak_demo",
      userId: user.id,
      organizationId: org.id,
      permissions: JSON.stringify(["read:users", "write:users"])
    }
  });

  logInfo("Database seeding completed", {
    status: "success",
    timestamp: new Date().toISOString()
  });
}

main()
  .catch((e) => {
    logError("Database seeding failed", {
      error: e.message,
      stack: e.stack,
      timestamp: new Date().toISOString()
    });
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

## Best Practices

<Warning>
  **Production Guidelines:** - Always use transactions for related operations -
  Implement proper error handling and logging - Use connection pooling for
  better performance - Regular backups and monitoring of database health -
  Secure API keys and session tokens properly
</Warning>

### Recommended Patterns

1. **Transaction Usage**
   - Use `$transaction` for related operations that must succeed or fail
     together
   - Keep transactions short to avoid blocking other operations
   - Handle transaction failures gracefully

2. **Query Optimization**
   - Use `select` to fetch only needed fields
   - Implement proper indexing for frequently queried fields
   - Use `include` judiciously to avoid N+1 query problems

3. **Security**
   - Hash sensitive data (API keys, 2FA secrets)
   - Implement proper audit logging for security events
   - Use soft deletes for user data to maintain referential integrity

4. **Performance**
   - Use batch operations for bulk inserts/updates
   - Implement proper pagination for large datasets
   - Monitor slow queries and optimize them
   - Clean up expired sessions and audit logs regularly

The Prisma integration provides a robust, type-safe foundation for
authentication and user management in the Forge platform, ensuring data
integrity, security, and developer productivity.
