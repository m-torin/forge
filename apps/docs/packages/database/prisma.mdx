---
title: "Prisma ORM (PostgreSQL)"
description:
  "Primary database with authentication and organization management using Prisma
  ORM and PostgreSQL"
icon: "database"
---

# Prisma ORM (PostgreSQL)

Primary database provider using Prisma ORM with PostgreSQL for authentication,
user management, and organization features.

## Overview

Prisma serves as the primary database layer for authentication and user
management in the Forge platform, providing type-safe database access with a
comprehensive schema covering authentication, organizations, teams, and security
features.

<CardGroup cols={2}>
  <Card title="Better Auth Integration" icon="users">
    Complete user management, organizations, API keys, and sessions
  </Card>
  <Card title="Team Management" icon="building">
    Organization, team, and member management with role-based access
  </Card>
  <Card title="Security Features" icon="shield-check">
    Two-factor authentication, passkeys, backup codes, and API key management
  </Card>
  <Card title="Type Safety" icon="shield-check">
    Full TypeScript integration with generated types
  </Card>
</CardGroup>

## Quick Start

<CodeGroup>
```typescript Next.js Server Components/Actions
import { prisma } from "@repo/database/prisma/server/next";
import { logInfo } from "@repo/observability/server/next";

// Basic user query const users = await prisma.user.findMany({ include: {
members: { include: { organization: true } }, accounts: true, sessions: true }
});

logInfo("Users retrieved", { count: users.length });

````

```typescript Edge Runtime
import { prisma } from "@repo/database/prisma/server/edge";

// Edge-compatible queries
const user = await prisma.user.findUnique({
  where: { id: userId },
  select: {
    id: true,
    name: true,
    email: true,
    image: true
  }
});
````

```typescript Raw Queries
import { prisma } from "@repo/database/prisma/server/next";

// Raw SQL for complex queries
const result = await prisma.$queryRaw`
  SELECT u.*, o.name as org_name
  FROM users u
  LEFT JOIN members m ON u.id = m.user_id
  LEFT JOIN organizations o ON m.organization_id = o.id
  WHERE u.created_at > ${new Date("2024-01-01")}
`;
```

</CodeGroup>

## Configuration

### Environment Variables

<AccordionGroup>
  <Accordion title="Database Connection" icon="database">
    ```bash
    # PostgreSQL connection string
    DATABASE_URL="postgresql://user:password@localhost:5432/database_name"

    # Optional: Direct connection for serverless
    DIRECT_URL="postgresql://user:password@localhost:5432/database_name"

    # Optional: Shadow database for migrations
    SHADOW_DATABASE_URL="postgresql://user:password@localhost:5432/shadow_db"
    ```

  </Accordion>

  <Accordion title="Connection Pooling" icon="network">
    ```bash
    # Connection pool settings
    DATABASE_POOL_SIZE=10
    DATABASE_POOL_TIMEOUT=20000
    DATABASE_POOL_IDLE_TIMEOUT=300000

    # For serverless environments
    DATABASE_CONNECTION_LIMIT=1
    ```

  </Accordion>
</AccordionGroup>

### Schema Management

<AccordionGroup>
  <Accordion title="Migrations" icon="git-branch">
    ```bash
    # Generate migration
    pnpm --filter @repo/database generate:migration

    # Apply migrations
    pnpm --filter @repo/database migrate

    # Reset database (development only)
    pnpm --filter @repo/database migrate:reset

    # Deploy to production
    pnpm --filter @repo/database migrate:deploy
    ```

  </Accordion>

  <Accordion title="Schema Generation" icon="code">
    ```bash
    # Generate Prisma client
    pnpm --filter @repo/database generate

    # Validate schema
    pnpm --filter @repo/database validate

    # Format schema
    pnpm --filter @repo/database format
    ```

  </Accordion>
</AccordionGroup>

## Core Models

### Authentication & User Management

<AccordionGroup>
  <Accordion title="User Management" icon="user">
    ```typescript
    // Create user with Better Auth integration
    const user = await prisma.user.create({
      data: {
        name: "John Doe",
        email: "john@example.com",
        emailVerified: new Date(),
        image: "https://example.com/avatar.jpg"
      }
    });

    // Update user profile
    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: {
        name: "John Smith",
        image: "https://example.com/new-avatar.jpg"
      }
    });

    // Soft delete user (preserve audit trail)
    const deletedUser = await prisma.user.update({
      where: { id: userId },
      data: {
        email: `deleted_${Date.now()}@example.com` // Ensure unique constraint
      }
    });
    ```

  </Accordion>

  <Accordion title="Session Management" icon="clock">
    ```typescript
    // Create user session
    const session = await prisma.session.create({
      data: {
        sessionToken: "unique-session-token",
        userId: user.id,
        expires: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days
      }
    });

    // Validate session
    const activeSession = await prisma.session.findUnique({
      where: { sessionToken: "session-token" },
      include: { user: true }
    });

    // Clean expired sessions
    await prisma.session.deleteMany({
      where: {
        expires: { lt: new Date() }
      }
    });
    ```

  </Accordion>

  <Accordion title="Account Linking" icon="link">
    ```typescript
    // Link social account to user
    const account = await prisma.account.create({
      data: {
        userId: user.id,
        type: "oauth",
        provider: "google",
        providerAccountId: "google-user-id",
        access_token: "access-token",
        refresh_token: "refresh-token",
        expires_at: Math.floor(Date.now() / 1000) + 3600
      }
    });

    // Find user by provider account
    const userWithAccount = await prisma.user.findFirst({
      where: {
        accounts: {
          some: {
            provider: "google",
            providerAccountId: "google-user-id"
          }
        }
      },
      include: { accounts: true }
    });
    ```

  </Accordion>
</AccordionGroup>

### Organization & Team Management

<AccordionGroup>
  <Accordion title="Organization Management" icon="building">
    ```typescript
    // Create organization with initial member
    const organization = await prisma.organization.create({
      data: {
        name: "Acme Corp",
        slug: "acme-corp",
        logo: "https://example.com/logo.png",
        members: {
          create: {
            userId: ownerId,
            role: "owner"
          }
        }
      },
      include: {
        members: {
          include: { user: true }
        }
      }
    });

    // Update organization settings
    const updatedOrg = await prisma.organization.update({
      where: { id: orgId },
      data: {
        name: "Acme Corporation",
        metadata: {
          industry: "Technology",
          size: "50-100",
          website: "https://acme.com"
        }
      }
    });

    // Get organization with member count
    const orgWithStats = await prisma.organization.findUnique({
      where: { id: orgId },
      include: {
        _count: {
          select: {
            members: true,
            apiKeys: true,
            invitations: true
          }
        }
      }
    });
    ```

  </Accordion>

  <Accordion title="Team Management" icon="users">
    ```typescript
    // Create team within organization
    const team = await prisma.team.create({
      data: {
        name: "Engineering",
        slug: "engineering",
        organizationId: orgId,
        members: {
          create: [
            { userId: leadId, role: "lead" },
            { userId: memberId, role: "member" }
          ]
        }
      }
    });

    // Add member to team
    const teamMember = await prisma.teamMember.create({
      data: {
        teamId: team.id,
        userId: newMemberId,
        role: "member"
      }
    });

    // Get team with members and their roles
    const teamWithMembers = await prisma.team.findUnique({
      where: { id: teamId },
      include: {
        members: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                image: true
              }
            }
          }
        },
        organization: true
      }
    });

    // Update team member role
    const updatedMember = await prisma.teamMember.update({
      where: {
        teamId_userId: {
          teamId: teamId,
          userId: memberId
        }
      },
      data: { role: "lead" }
    });
    ```

  </Accordion>

  <Accordion title="Invitation Management" icon="mail">
    ```typescript
    // Send organization invitation
    const invitation = await prisma.invitation.create({
      data: {
        email: "newmember@example.com",
        organizationId: orgId,
        invitedById: inviterId,
        role: "member",
        token: "unique-invitation-token",
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
      }
    });

    // Accept invitation
    const acceptedInvitation = await prisma.$transaction(async (tx) => {
      // Create organization member
      const member = await tx.member.create({
        data: {
          userId: acceptingUserId,
          organizationId: invitation.organizationId,
          role: invitation.role
        }
      });

      // Mark invitation as accepted
      await tx.invitation.update({
        where: { id: invitation.id },
        data: {
          status: "accepted",
          acceptedAt: new Date()
        }
      });

      return member;
    });

    // Get pending invitations for organization
    const pendingInvitations = await prisma.invitation.findMany({
      where: {
        organizationId: orgId,
        status: "pending",
        expiresAt: { gt: new Date() }
      },
      include: {
        invitedBy: {
          select: { name: true, email: true }
        }
      }
    });
    ```

  </Accordion>
</AccordionGroup>

### Security & API Management

<AccordionGroup>
  <Accordion title="API Key Management" icon="key">
    ```typescript
    // Create API key for organization
    const apiKey = await prisma.apiKey.create({
      data: {
        name: "Production API Key",
        organizationId: orgId,
        keyHash: "hashed-key-value",
        permissions: ["read:users", "write:data"],
        expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year
        metadata: {
          environment: "production",
          createdBy: userId
        }
      }
    });

    // Validate API key
    const validKey = await prisma.apiKey.findFirst({
      where: {
        keyHash: hashedKey,
        expiresAt: { gt: new Date() },
        revokedAt: null
      },
      include: {
        organization: {
          select: { id: true, name: true, slug: true }
        }
      }
    });

    // Revoke API key
    const revokedKey = await prisma.apiKey.update({
      where: { id: keyId },
      data: {
        revokedAt: new Date(),
        revokedBy: revokingUserId
      }
    });

    // Update API key permissions
    const updatedKey = await prisma.apiKey.update({
      where: { id: keyId },
      data: {
        permissions: ["read:users", "read:organizations"],
        lastUsedAt: new Date()
      }
    });
    ```

  </Accordion>

  <Accordion title="Two-Factor Authentication" icon="shield">
    ```typescript
    // Setup 2FA for user
    const twoFactor = await prisma.twoFactor.create({
      data: {
        userId: userId,
        secret: "encrypted-totp-secret",
        backupCodes: [
          "encrypted-backup-code-1",
          "encrypted-backup-code-2",
          // ... more backup codes
        ]
      }
    });

    // Verify 2FA setup
    const verifiedTwoFactor = await prisma.twoFactor.update({
      where: { userId: userId },
      data: {
        verifiedAt: new Date(),
        isActive: true
      }
    });

    // Use backup code
    const twoFactorRecord = await prisma.twoFactor.findUnique({
      where: { userId: userId }
    });

    if (twoFactorRecord?.backupCodes.includes(hashedBackupCode)) {
      await prisma.twoFactor.update({
        where: { userId: userId },
        data: {
          backupCodes: twoFactorRecord.backupCodes.filter(
            code => code !== hashedBackupCode
          ),
          lastUsedAt: new Date()
        }
      });
    }
    ```

  </Accordion>

  <Accordion title="Passkey Management" icon="fingerprint">
    ```typescript
    // Register new passkey
    const passkey = await prisma.passkey.create({
      data: {
        userId: userId,
        credentialId: "base64-credential-id",
        publicKey: "base64-public-key",
        counter: 0,
        name: "iPhone Face ID",
        transports: ["internal", "hybrid"],
        metadata: {
          aaguid: "device-aaguid",
          userAgent: request.headers["user-agent"]
        }
      }
    });

    // Update passkey counter after use
    const updatedPasskey = await prisma.passkey.update({
      where: { credentialId: credentialId },
      data: {
        counter: newCounter,
        lastUsedAt: new Date()
      }
    });

    // Get user's passkeys
    const userPasskeys = await prisma.passkey.findMany({
      where: { userId: userId },
      select: {
        id: true,
        name: true,
        createdAt: true,
        lastUsedAt: true,
        transports: true
      },
      orderBy: { lastUsedAt: "desc" }
    });

    // Remove passkey
    await prisma.passkey.delete({
      where: { id: passkeyId }
    });
    ```

  </Accordion>
</AccordionGroup>

### Audit Logging

<AccordionGroup>
  <Accordion title="Security Audit Trail" icon="list-check">
    ```typescript
    // Log authentication events
    const auditLog = await prisma.auditLog.create({
      data: {
        action: "user.login",
        userId: userId,
        organizationId: orgId,
        ipAddress: request.ip,
        userAgent: request.headers["user-agent"],
        metadata: {
          method: "passkey",
          success: true,
          timestamp: new Date().toISOString()
        }
      }
    });

    // Log sensitive operations
    const sensitiveAction = await prisma.auditLog.create({
      data: {
        action: "apikey.created",
        userId: creatorId,
        organizationId: orgId,
        resourceId: apiKey.id,
        resourceType: "apikey",
        metadata: {
          keyName: apiKey.name,
          permissions: apiKey.permissions,
          expiresAt: apiKey.expiresAt?.toISOString()
        }
      }
    });

    // Query audit logs with filters
    const recentLogs = await prisma.auditLog.findMany({
      where: {
        organizationId: orgId,
        createdAt: {
          gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
        },
        action: {
          in: ["user.login", "user.logout", "apikey.created", "apikey.revoked"]
        }
      },
      include: {
        user: {
          select: { name: true, email: true }
        }
      },
      orderBy: { createdAt: "desc" },
      take: 100
    });

    // Aggregate audit statistics
    const auditStats = await prisma.auditLog.groupBy({
      by: ["action"],
      where: {
        organizationId: orgId,
        createdAt: {
          gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
        }
      },
      _count: { action: true },
      orderBy: { _count: { action: "desc" } }
    });
    ```

  </Accordion>
</AccordionGroup>

## Advanced Queries

### Complex Joins and Aggregations

<AccordionGroup>
  <Accordion title="User Analytics" icon="chart-line">
    ```typescript
    // User engagement analytics
    const userStats = await prisma.user.findMany({
      where: {
        members: {
          some: {
            organizationId: orgId
          }
        }
      },
      include: {
        _count: {
          select: {
            sessions: {
              where: {
                createdAt: {
                  gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
                }
              }
            },
            accounts: true
          }
        },
        sessions: {
          where: {
            createdAt: {
              gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
            }
          },
          orderBy: { createdAt: "desc" },
          take: 1,
          select: { createdAt: true }
        }
      }
    });

    // Organization growth metrics
    const growthMetrics = await prisma.organization.findUnique({
      where: { id: orgId },
      include: {
        _count: {
          select: {
            members: true,
            teams: true,
            apiKeys: {
              where: { revokedAt: null }
            },
            invitations: {
              where: { status: "pending" }
            }
          }
        }
      }
    });
    ```

  </Accordion>

  <Accordion title="Performance Optimization" icon="gauge">
    ```typescript
    // Optimized queries with proper indexing
    const optimizedUserQuery = await prisma.user.findMany({
      where: {
        AND: [
          { emailVerified: { not: null } },
          {
            members: {
              some: {
                organizationId: orgId,
                role: { in: ["owner", "admin", "member"] }
              }
            }
          }
        ]
      },
      select: {
        id: true,
        name: true,
        email: true,
        image: true,
        createdAt: true,
        members: {
          where: { organizationId: orgId },
          select: {
            role: true,
            createdAt: true,
            organization: {
              select: { name: true, slug: true }
            }
          }
        }
      },
      orderBy: { createdAt: "desc" },
      take: 50
    });

    // Batch operations for better performance
    const batchUpdateMembers = await prisma.member.updateMany({
      where: {
        organizationId: orgId,
        role: "member",
        createdAt: {
          lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) // 90 days ago
        }
      },
      data: {
        metadata: {
          veteranMember: true,
          badgeEarned: new Date()
        }
      }
    });

    // Connection counting for pagination
    const usersWithPagination = await prisma.user.findMany({
      skip: (page - 1) * pageSize,
      take: pageSize,
      where: { /* filters */ },
      orderBy: { createdAt: "desc" }
    });

    const totalUsers = await prisma.user.count({
      where: { /* same filters */ }
    });
    ```

  </Accordion>
</AccordionGroup>

## Database Operations

### Migrations and Schema Updates

<AccordionGroup>
  <Accordion title="Migration Best Practices" icon="git-merge">
    ```bash
    # Create descriptive migration
    pnpm --filter @repo/database generate:migration --name add_user_preferences

    # Preview migration changes
    pnpm --filter @repo/database migrate:diff --preview-feature

    # Apply migration with rollback plan
    pnpm --filter @repo/database migrate:deploy

    # Reset development database
    pnpm --filter @repo/database migrate:reset --force
    ```

  </Accordion>

  <Accordion title="Data Seeding" icon="seedling">
    ```typescript
    // Development seed data
    import { PrismaClient } from "@prisma/client";

    const prisma = new PrismaClient();

    async function seed() {
      // Create test organization
      const org = await prisma.organization.create({
        data: {
          name: "Test Organization",
          slug: "test-org",
          members: {
            create: {
              role: "owner",
              user: {
                create: {
                  name: "Admin User",
                  email: "admin@test.com",
                  emailVerified: new Date()
                }
              }
            }
          }
        }
      });

      console.log("Seed data created:", org);
    }

    seed().catch(console.error).finally(() => prisma.$disconnect());
    ```

  </Accordion>
</AccordionGroup>

## Error Handling

<AccordionGroup>
  <Accordion title="Common Error Patterns" icon="exclamation-triangle">
    ```typescript
    import { Prisma } from "@prisma/client";

    try {
      const user = await prisma.user.create({
        data: { email: "existing@example.com" }
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === "P2002") {
          // Unique constraint violation
          throw new Error("Email already exists");
        }
        if (error.code === "P2025") {
          // Record not found
          throw new Error("User not found");
        }
      }
      throw error; // Re-throw unexpected errors
    }
    ```

  </Accordion>

  <Accordion title="Transaction Error Handling" icon="refresh">
    ```typescript
    try {
      const result = await prisma.$transaction(async (tx) => {
        const user = await tx.user.create({
          data: { name: "John", email: "john@example.com" }
        });

        const org = await tx.organization.create({
          data: {
            name: "John's Org",
            slug: "johns-org",
            members: {
              create: { userId: user.id, role: "owner" }
            }
          }
        });

        return { user, org };
      });

      return result;
    } catch (error) {
      // Transaction automatically rolled back
      console.error("Transaction failed:", error);
      throw new Error("Failed to create user and organization");
    }
    ```

  </Accordion>
</AccordionGroup>

## Performance & Monitoring

<AccordionGroup>
  <Accordion title="Query Optimization" icon="zap">
    ```typescript
    // Use proper indexes and select only needed fields
    const optimizedQuery = await prisma.user.findMany({
      where: {
        members: {
          some: { organizationId: orgId }
        }
      },
      select: {
        id: true,
        name: true,
        email: true,
        // Don't select unnecessary fields
      },
      take: 20 // Limit results
    });

    // Use explain to analyze query performance
    const queryPlan = await prisma.$queryRaw`
      EXPLAIN ANALYZE
      SELECT * FROM users
      WHERE email = ${"user@example.com"}
    `;
    ```

  </Accordion>

  <Accordion title="Connection Management" icon="network">
    ```typescript
    // Proper connection handling
    import { PrismaClient } from "@prisma/client";

    // Global instance with connection pooling
    const globalForPrisma = globalThis as unknown as {
      prisma: PrismaClient | undefined;
    };

    const prisma = globalForPrisma.prisma ?? new PrismaClient({
      log: process.env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"]
    });

    if (process.env.NODE_ENV !== "production") {
      globalForPrisma.prisma = prisma;
    }

    // Graceful shutdown
    process.on("SIGINT", async () => {
      await prisma.$disconnect();
      process.exit(0);
    });
    ```

  </Accordion>
</AccordionGroup>

## Testing

<AccordionGroup>
  <Accordion title="Test Database Setup" icon="flask">
    ```typescript
    // Test utilities with database cleanup
    import { PrismaClient } from "@prisma/client";

    const testPrisma = new PrismaClient({
      datasources: {
        db: { url: process.env.TEST_DATABASE_URL }
      }
    });

    export async function cleanupDatabase() {
      const tablenames = await testPrisma.$queryRaw<Array<{ tablename: string }>>`
        SELECT tablename FROM pg_tables WHERE schemaname='public'
      `;

      for (const { tablename } of tablenames) {
        if (tablename !== "_prisma_migrations") {
          await testPrisma.$executeRawUnsafe(`TRUNCATE TABLE "public"."${tablename}" CASCADE;`);
        }
      }
    }

    export { testPrisma };
    ```

  </Accordion>

  <Accordion title="Test Factories" icon="wrench">
    ```typescript
    // User factory for consistent test data
    export async function createTestUser(overrides: Partial<User> = {}) {
      return await testPrisma.user.create({
        data: {
          name: "Test User",
          email: `test-${Date.now()}@example.com`,
          emailVerified: new Date(),
          ...overrides
        }
      });
    }

    export async function createTestOrganization(ownerId: string, overrides: Partial<Organization> = {}) {
      return await testPrisma.organization.create({
        data: {
          name: "Test Organization",
          slug: `test-org-${Date.now()}`,
          members: {
            create: { userId: ownerId, role: "owner" }
          },
          ...overrides
        }
      });
    }
    ```

  </Accordion>
</AccordionGroup>
