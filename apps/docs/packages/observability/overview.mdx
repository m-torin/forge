---
title: "Observability Package"
description:
  "Comprehensive monitoring infrastructure with error tracking, performance
  monitoring, and analytics"
icon: "chart-mixed"
---

# Observability Package

Comprehensive observability infrastructure with error tracking, structured
logging, performance monitoring, and system status monitoring built on Sentry,
Logtail, and BetterStack.

## Overview

The observability package provides a complete monitoring and tracking solution
for production applications, featuring automatic error capture, structured
logging, performance tracking, and real-time analytics integration across all
Forge applications.

## Key Features

<CardGroup cols={2}>
  <Card title="Sentry Integration" icon="bug">
    Error tracking, performance monitoring, and session replay with
    privacy-first defaults
  </Card>
  <Card title="Structured Logging" icon="list">
    Environment-aware logging with Logtail in production, console fallback in
    development
  </Card>
  <Card title="Performance Monitoring" icon="gauge">
    Automatic timing and performance tracking with specialized React hooks
  </Card>
  <Card title="Analytics Integration" icon="chart-line">
    User behavior tracking and workflow analytics with purpose-built hooks
  </Card>
</CardGroup>

### Advanced Features

- **System Status Monitoring**: Real-time status display with BetterStack
  integration
- **Next.js Integration**: Seamless framework integration with automatic source
  map uploading
- **React Hooks**: Purpose-built hooks for observability in React applications
- **Environment Aware**: Smart configuration that adapts to development vs
  production

## Installation

```bash
pnpm add @repo/observability
```

## Environment Variables

<Tabs>
  <Tab title="Sentry Configuration">
```bash
# Sentry Configuration
SENTRY_DSN=https://...@...ingest.sentry.io/...
SENTRY_ORG=your-sentry-org
SENTRY_PROJECT=your-sentry-project
# Sentry Authentication (for uploads)
SENTRY_AUTH_TOKEN=...
```

</Tab>

  <Tab title="Logging & Monitoring">
```bash
# Logtail Logging (Production)
LOGTAIL_SOURCE_TOKEN=...
# BetterStack Status Monitoring
BETTERSTACK_API_URL=https://betterstack.com/api/...
BETTERSTACK_BEARER_TOKEN=...
# Vercel Cron Monitoring (Optional)
SENTRY_PROJECT_URL=https://your-project.vercel.app
```

</Tab>
</Tabs>

## Setup

### Next.js Application Setup

<Steps>
  <Step title="Instrumentation">
    ```typescript
    // instrumentation.ts (in app root)
    export async function register() {
      if (process.env.NEXT_RUNTIME === 'nodejs') {
        await import('@repo/observability/instrumentation');
      }
    }
    ```
  </Step>

<Step title="Client Configuration">
  ```typescript // sentry.client.config.ts (in app root) import
  '@repo/observability/client'; ```
</Step>

  <Step title="Next.js Config Integration">
    ```typescript
    // next.config.ts
    import { withSentry } from '@repo/observability/next-wrappers';

    const config = {
      // Your Next.js config
    };

    export default withSentry(config);
    ```

  </Step>
</Steps>

## Error Tracking

### Automatic Error Capture

The observability package provides automatic error parsing and capture:

```typescript
// Server-side error parsing
import { parseError } from "@repo/observability/server/next";

// Client-side error parsing
import { parseError } from "@repo/observability/client/next";

try {
  await riskyOperation();
} catch (error) {
  // Automatically captures to Sentry and returns standardized message
  const errorMessage = parseError(error);
  logError("Operation failed", {
    error: errorMessage,
    code: error.code,
    timestamp: new Date().toISOString()
  });
}
```

### Manual Error Reporting

<CodeGroup>
```typescript Custom Error Reporting
import { captureException } from '@sentry/nextjs';

// Report custom errors with context captureException(new Error('Custom error'),
{ tags: { component: 'UserProfile', action: 'updateProfile', }, extra: { userId:
user.id, organizationId: org.id, }, });

````

```typescript Error Context
import { setUser, setTag, setContext } from '@sentry/nextjs';

// Set user context
setUser({
  id: user.id,
  email: user.email,
  organization: org.name,
});

// Add custom tags
setTag('feature', 'ai-classification');
setTag('environment', process.env.NODE_ENV);

// Add custom context
setContext('workflow', {
  workflowId: workflow.id,
  status: workflow.status,
  stepCount: workflow.steps.length,
});
````

</CodeGroup>

## Logging

### Quick Start (New Simplified API)

The observability package now provides simplified logging functions that handle
async operations internally:

```typescript
import {
  logInfo,
  logError,
  logWarn,
  logDebug
} from "@repo/observability/server/next";

// Fire-and-forget logging - no await needed!
logInfo("User logged in", { userId: user.id, timestamp: Date.now() });

// Error logging with automatic error serialization
try {
  await riskyOperation();
} catch (error) {
  logError("Operation failed", error, { operation: "user-update" });
}

// Debug logging (only shown in development by default)
logDebug("Processing request", { path: request.url });

// Warning logging
logWarn("Rate limit approaching", { current: 85, limit: 100 });
```

### Benefits of the New Pattern

<CardGroup cols={2}>
  <Card title="No Blocking" icon="bolt">
    Fire-and-forget design means logging never blocks your application flow
  </Card>
  <Card title="Smart Defaults" icon="brain">
    Automatically uses console logging in development, production providers in
    production
  </Card>
  <Card title="Edge Compatible" icon="globe">
    Works seamlessly in Node.js, Next.js, and edge runtime environments
  </Card>
  <Card title="Type Safe" icon="shield-check">
    Full TypeScript support with proper error handling
  </Card>
</CardGroup>

### Environment-Specific Imports

```typescript
// Next.js server components, API routes, server actions
import { logInfo } from "@repo/observability/server/next";

// Edge runtime (middleware, edge functions)
import { logInfo } from "@repo/observability/server/edge";

// Standard Node.js applications
import { logInfo } from "@repo/observability/server";

// Environment-agnostic packages
import { logInfo } from "@repo/observability";
```

### Optional Configuration

While the logger works out-of-the-box with sensible defaults, you can customize
it:

```typescript
import { configureLogger, logInfo } from "@repo/observability/server/next";

// Configure once at application startup
configureLogger({
  providers: {
    console: {
      enabled: true,
      level: "debug",
      prefix: "[MyApp]"
    },
    sentry: {
      dsn: process.env.SENTRY_DSN
    }
  }
});

// Then use anywhere in your app
logInfo("Application started");
```

## Structured Logging (Legacy Pattern)

<Warning>
  **Deprecated**: The `log()` function is deprecated. Use `logInfo()`,
  `logError()`, etc. instead.
</Warning>

### Legacy Environment-Aware Logging

The legacy logging system requires await and manual logger creation:

```typescript
// ⚠️ DEPRECATED - Use new pattern above
import { createLogger } from "@repo/observability/server/next";

const logger = createLogger();

// Old pattern - requires await
await logger.info("User action completed", {
  userId: user.id,
  action: "profile_update"
});
```

## Performance Monitoring

### Performance Timer Hook

Track timing for async operations automatically:

```typescript
import { usePerformanceTimer } from '@repo/observability';

function DataComponent() {
  const { time } = usePerformanceTimer();

  const loadData = async () => {
    // Automatically tracks timing and logs performance
    const data = await time(
      'load-user-data',
      () => fetchUserData(userId),
      {
        userId,
        organizationId: org.id,
      }
    );

    setData(data);
  };

  return (
    <button onClick={loadData}>
      Load Data
    </button>
  );
}
```

### Custom Performance Tracking

For complex operations requiring manual control:

```typescript
import { startTransaction } from "@sentry/nextjs";

// Manual performance tracking
const transaction = startTransaction({
  name: "workflow-execution",
  op: "workflow"
});

transaction.setTag("workflowType", "product-classification");
transaction.setData("productCount", products.length);

try {
  const results = await executeWorkflow(products);
  transaction.setStatus("ok");
} catch (error) {
  transaction.setStatus("internal_error");
  throw error;
} finally {
  transaction.finish();
}
```

## React Observability Hooks

### General Observability Hook

Comprehensive tracking for React components:

<AccordionGroup>
  <Accordion title="Event Tracking" icon="mouse-pointer">
    ```typescript
    import { useObservability } from '@repo/observability';

    function ProductCard({ product }) {
      const { trackEvent, trackError, trackPerformance } = useObservability();

      const handleAddToCart = async () => {
        trackEvent('add_to_cart_clicked', {
          productId: product.id,
          price: product.price,
        });

        try {
          const startTime = performance.now();
          await addToCart(product.id);

          trackPerformance('add_to_cart_duration', performance.now() - startTime);
          trackEvent('add_to_cart_success', { productId: product.id });
        } catch (error) {
          trackError('add_to_cart_failed', error, {
            productId: product.id,
          });
        }
      };

      return (
        <button onClick={handleAddToCart}>
          Add to Cart
        </button>
      );
    }
    ```

  </Accordion>

  <Accordion title="Workflow Tracking" icon="workflow">
    ```typescript
    import { useWorkflowObservability } from '@repo/observability';

    function WorkflowRunner({ workflowId }) {
      const {
        trackWorkflowStart,
        trackWorkflowStep,
        trackWorkflowComplete,
        trackWorkflowError
      } = useWorkflowObservability();

      const executeWorkflow = async () => {
        trackWorkflowStart(workflowId, {
          triggerType: 'manual',
          organizationId: org.id,
        });

        try {
          for (const step of workflow.steps) {
            trackWorkflowStep(workflowId, step.id, {
              stepType: step.type,
              inputSize: step.input?.length,
            });

            await executeStep(step);
          }

          trackWorkflowComplete(workflowId, {
            duration: performance.now() - startTime,
            stepCount: workflow.steps.length,
          });
        } catch (error) {
          trackWorkflowError(workflowId, error, {
            failedStep: currentStep.id,
          });
        }
      };
    }
    ```

  </Accordion>
</AccordionGroup>

### Workflow Analytics Integration

The observability package integrates with existing workflow systems to provide
comprehensive tracking for multi-step processes:

```typescript
// Available hooks for workflow tracking
import { useWorkflowObservability } from '@repo/observability';

function WorkflowComponent({ workflowType }: { workflowType: string }) {
  const {
    trackWorkflowEvent,
    trackWorkflowError,
    trackWorkflowPerformance
  } = useWorkflowObservability(workflowType);

  const handleWorkflowStep = async (stepName: string) => {
    const startTime = performance.now();

    try {
      trackWorkflowEvent('step-started', { stepName });

      await executeStep(stepName);

      const duration = performance.now() - startTime;
      trackWorkflowPerformance('step-execution', duration, { stepName });
      trackWorkflowEvent('step-completed', { stepName, duration });
    } catch (error) {
      trackWorkflowError(error, { stepName });
      throw error;
    }
  };

  return (
    <div>
      <button onClick={() => handleWorkflowStep('data-processing')}>
        Start Processing
      </button>
    </div>
  );
}
```

## Performance Analysis

### Custom Performance Monitoring

Use the performance timer hook for detailed timing analysis:

```typescript
import { usePerformanceTimer } from '@repo/observability';

function DataAnalysisComponent() {
  const { time, startTimer, endTimer } = usePerformanceTimer();

  const analyzeData = async (dataset: any[]) => {
    // Automatic timing with async operations
    const result = await time(
      'data-analysis',
      async () => {
        return await processLargeDataset(dataset);
      },
      { datasetSize: dataset.length }
    );

    return result;
  };

  const manualTiming = async () => {
    const transaction = startTimer('manual-operation', {
      operationType: 'custom'
    });

    try {
      await performComplexOperation();
    } finally {
      endTimer('manual-operation', {
        status: 'completed'
      });
    }
  };

  return (
    <div>
      <button onClick={() => analyzeData(largeDataset)}>
        Analyze Data
      </button>
    </div>
  );
}
```

## Advanced Configuration

### Session Replay Configuration

Session replay is automatically configured with privacy-first settings:

<Note>
  **Privacy-First Defaults:** - Mask all text content - Block media elements -
  10% sample rate - Privacy-compliant data collection
</Note>

### Custom Sampling

```typescript
// Custom error sampling (in sentry config)
beforeSend(event, hint) {
  // Filter out known non-critical errors
  if (event.exception?.values?.[0]?.type === 'ChunkLoadError') {
    return null;
  }

  // Sample high-volume errors
  if (event.tags?.component === 'HighVolumeComponent') {
    return Math.random() < 0.1 ? event : null;
  }

  return event;
}
```

### Environment Behavior

<CardGroup cols={2}>
  <Card title="Development" icon="laptop-code">
    - Console logging fallback - Optional environment variables - Reduced
    sampling rates - Local debugging support
  </Card>
  <Card title="Production" icon="server">
    - Logtail structured logging - Required environment variables - Full error
    capture and replay - Performance optimization
  </Card>
</CardGroup>

## Testing

### Mock Observability

```typescript
import { vi } from "vitest";

// Mock observability in tests
vi.mock("@repo/observability/client/next", () => ({
  parseError: vi.fn((error) => error.message),
  useObservability: () => ({
    trackEvent: vi.fn(),
    trackError: vi.fn(),
    trackPerformance: vi.fn(),
    log: vi.fn(),
    captureException: vi.fn()
  })
}));

vi.mock("@repo/observability/server/next", () => ({
  logInfo: vi.fn(),
  logError: vi.fn(),
  logWarn: vi.fn(),
  logDebug: vi.fn(),
  parseError: vi.fn((error) => error.message)
}));
```

## Migration Guide

### Migrating from Legacy Logger Pattern

The new simplified logger functions provide better developer experience and
performance:

<CodeGroup>
```typescript Old Pattern (Deprecated)
import { createLogger } from '@repo/observability/server/next';

const logger = createLogger();

export async function processUser(userId: string) {
  await logger.debug('Starting user processing', { userId });

try { const user = await fetchUser(userId); await logger.info('User fetched', {
userId, status: user.status });

    const result = await updateUser(user);
    await logger.info('User updated', { userId, changes: result.changes });

    return result;

} catch (error) { await logger.error('User processing failed', error, { userId
}); throw error; } }

````

```typescript New Pattern (Recommended)
import { logDebug, logInfo, logError } from "@repo/observability/server/next";

export async function processUser(userId: string) {
  logDebug("Starting user processing", { userId });

  try {
    const user = await fetchUser(userId);
    logInfo("User fetched", { userId, status: user.status });

    const result = await updateUser(user);
    logInfo("User updated", { userId, changes: result.changes });

    return result;
  } catch (error) {
    logError("User processing failed", error, { userId });
    throw error;
  }
}
````

</CodeGroup>

### Key Migration Points

1. **No more await**: Logger functions are now fire-and-forget
2. **Direct imports**: Import specific functions instead of creating logger
   instances
3. **Same API**: Context and error parameters work the same way
4. **Backwards compatible**: Old pattern still works but shows deprecation
   warnings

## Best Practices

<Warning>
  **Implementation Guidelines:** - Always provide relevant context with errors -
  Use performance timer hook for async operations - Track user interactions for
  product insights - Session replay automatically masks sensitive data - Prefer
  new logger functions for better performance
</Warning>

### Recommended Patterns

1. **Error Context**: Include user ID, organization ID, and action context
2. **Performance Tracking**: Monitor critical user journeys and API calls
3. **Analytics Integration**: Track business-relevant user interactions
4. **Privacy First**: Leverage automatic data masking in session replay
5. **Environment Awareness**: Package adapts automatically to dev/prod
6. **Structured Logging**: Use structured data for better log analysis
7. **Error Boundaries**: Implement at component level for graceful failures
8. **Non-blocking Logs**: Use new fire-and-forget logger functions

The observability package provides comprehensive monitoring infrastructure while
maintaining simplicity and privacy-first defaults, enabling teams to understand
system behavior and user interactions across the entire Forge platform.
