---
title: "Observability Package"
description:
  "Comprehensive monitoring infrastructure with error tracking, performance
  monitoring, and analytics"
icon: "chart-mixed"
---

# Observability Package

Comprehensive observability infrastructure with error tracking, structured
logging, performance monitoring, and system status monitoring built on Sentry,
Logtail, and BetterStack.

## Overview

The observability package provides a complete monitoring and tracking solution
for production applications, featuring automatic error capture, structured
logging, performance tracking, and real-time analytics integration across all
Forge applications.

## Key Features

<CardGroup cols={2}>
  <Card title="Sentry Integration" icon="bug">
    Error tracking, performance monitoring, and session replay with
    privacy-first defaults
  </Card>
  <Card title="Structured Logging" icon="list">
    Environment-aware logging with Logtail in production, console fallback in
    development
  </Card>
  <Card title="Performance Monitoring" icon="gauge">
    Automatic timing and performance tracking with specialized React hooks
  </Card>
  <Card title="Analytics Integration" icon="chart-line">
    User behavior tracking and workflow analytics with purpose-built hooks
  </Card>
</CardGroup>

### Advanced Features

- **System Status Monitoring**: Real-time status display with BetterStack
  integration
- **Next.js Integration**: Seamless framework integration with automatic source
  map uploading
- **React Hooks**: Purpose-built hooks for observability in React applications
- **Environment Aware**: Smart configuration that adapts to development vs
  production

## Installation

The observability package is typically already included in Forge workspaces. If
you need to add it manually:

```bash
pnpm add @repo/observability
```

<Note>
  This package follows the four-file export pattern for proper Next.js
  integration. Always use the appropriate import path for your environment.
</Note>

## Environment Variables

<Tabs>
  <Tab title="Sentry Configuration">
```bash
# Sentry Configuration
SENTRY_DSN=https://...@...ingest.sentry.io/...
SENTRY_ORG=your-sentry-org
SENTRY_PROJECT=your-sentry-project
# Sentry Authentication (for uploads)
SENTRY_AUTH_TOKEN=...
```

</Tab>

  <Tab title="Logging & Monitoring">
```bash
# Logtail Logging (Production)
LOGTAIL_SOURCE_TOKEN=...
# BetterStack Status Monitoring
BETTERSTACK_API_URL=https://betterstack.com/api/...
BETTERSTACK_BEARER_TOKEN=...
# Vercel Cron Monitoring (Optional)
SENTRY_PROJECT_URL=https://your-project.vercel.app
```

</Tab>
</Tabs>

## Setup

### Next.js Application Setup

<Steps>
  <Step title="Server-side Initialization">
    ```typescript
    // instrumentation.ts (in app root)
    export async function register() {
      if (process.env.NEXT_RUNTIME === 'nodejs') {
        const { getObservability } = await import('@repo/observability/server/next');
        await getObservability();
      }
    }
    ```
  </Step>

  <Step title="Client-side Initialization">
    ```typescript
    // app/layout.tsx
    import { useEffect } from 'react';
    
    export default function RootLayout({ children }: { children: React.ReactNode }) {
      useEffect(() => {
        // Initialize client-side observability
        import('@repo/observability/client/next').then(({ getObservability }) => {
          getObservability();
        });
      }, []);
      
      return (
        <html>
          <body>{children}</body>
        </html>
      );
    }
    ```
  </Step>

  <Step title="Environment Configuration">
    Ensure your app's `env.ts` extends the observability environment:
    ```typescript
    // env.ts
    import { createEnv } from "@t3-oss/env-nextjs";
    import { env as observabilityEnv } from "@repo/observability/env";
    import { z } from "zod";

    export const env = createEnv({
      extends: [observabilityEnv],
      server: {
        // Your app-specific server variables
      },
      client: {
        // Your app-specific client variables
      },
      // ... rest of config
    });
    ```

  </Step>
</Steps>

## Error Tracking

### Automatic Error Capture

The observability package provides automatic error capture through its logging
functions:

```typescript
// Server-side error logging
import { logError, logInfo } from "@repo/observability/server/next";

// Client-side error logging
import { logError, logInfo } from "@repo/observability/client/next";

try {
  await riskyOperation();
  logInfo("Operation completed successfully");
} catch (error) {
  // Automatically captures to Sentry and other configured providers
  logError("Operation failed", {
    error: error instanceof Error ? error.message : String(error),
    code: (error as any)?.code,
    timestamp: new Date().toISOString(),
    operation: "riskyOperation"
  });

  // Or pass the error directly
  logError(error, { operation: "riskyOperation" });
}
```

### Manual Error Reporting

<CodeGroup>
```typescript Custom Error Reporting
import { getObservability } from '@repo/observability/server/next';

// Report custom errors with context const observability = await
getObservability(); observability.captureException(new Error('Custom error'), {
component: 'UserProfile', action: 'updateProfile', userId: user.id,
organizationId: org.id, });

// Or use the logging functions directly import { logError } from
'@repo/observability/server/next'; logError(new Error('Custom error'), {
component: 'UserProfile', action: 'updateProfile', userId: user.id,
organizationId: org.id, });

````

```typescript Setting User Context
import { getObservability } from '@repo/observability/server/next';

const observability = await getObservability();

// Set user context
observability.setUser({
  id: user.id,
  email: user.email,
  username: user.username,
  organization: org.name,
});

// Add breadcrumbs for debugging
observability.addBreadcrumb({
  message: 'User updated profile',
  category: 'user.action',
  level: 'info',
  data: {
    workflowId: workflow.id,
    status: workflow.status,
    stepCount: workflow.steps.length,
  }
});
````

</CodeGroup>

## Logging

### Quick Start (New Simplified API)

The observability package now provides simplified logging functions that handle
async operations internally:

```typescript
import {
  logInfo,
  logError,
  logWarn,
  logDebug
} from "@repo/observability/server/next";

// Fire-and-forget logging - no await needed!
logInfo("User logged in", { userId: user.id, timestamp: Date.now() });

// Error logging with automatic error serialization
try {
  await riskyOperation();
} catch (error) {
  logError("Operation failed", error, { operation: "user-update" });
}

// Debug logging (only shown in development by default)
logDebug("Processing request", { path: request.url });

// Warning logging
logWarn("Rate limit approaching", { current: 85, limit: 100 });
```

### Benefits of the New Pattern

<CardGroup cols={2}>
  <Card title="No Blocking" icon="bolt">
    Fire-and-forget design means logging never blocks your application flow
  </Card>
  <Card title="Smart Defaults" icon="brain">
    Automatically uses console logging in development, production providers in
    production
  </Card>
  <Card title="Edge Compatible" icon="globe">
    Works seamlessly in Node.js, Next.js, and edge runtime environments
  </Card>
  <Card title="Type Safe" icon="shield-check">
    Full TypeScript support with proper error handling
  </Card>
</CardGroup>

### Environment-Specific Imports

```typescript
// Next.js server components, API routes, server actions
import {
  logInfo,
  logError,
  logWarn,
  logDebug
} from "@repo/observability/server/next";

// Next.js client components and client-side code
import {
  logInfo,
  logError,
  logWarn,
  logDebug
} from "@repo/observability/client/next";

// Edge runtime (middleware, edge functions)
import {
  logInfo,
  logError,
  logWarn,
  logDebug
} from "@repo/observability/server/edge";

// Standard Node.js applications
import {
  logInfo,
  logError,
  logWarn,
  logDebug
} from "@repo/observability/server";

// Generic client-side (browser)
import {
  logInfo,
  logError,
  logWarn,
  logDebug
} from "@repo/observability/client";

// Environment-agnostic packages (uses runtime detection)
import { logInfo, logError, logWarn, logDebug } from "@repo/observability";
```

### Optional Configuration

The observability system auto-configures based on available environment
variables. For custom configuration:

```typescript
import {
  createServerObservability,
  getObservability,
  ObservabilityBuilder
} from "@repo/observability/server/next";
import {
  createConsoleServerPlugin,
  createSentryPlugin
} from "@repo/observability/server/next";

// Custom observability configuration
const customObservability = ObservabilityBuilder.create()
  .withPlugin(
    createConsoleServerPlugin({
      prefix: "[MyApp]",
      enabled: true
    })
  )
  .withPlugin(
    createSentryPlugin({
      dsn: process.env.SENTRY_DSN,
      environment: process.env.NODE_ENV
    })
  )
  .build();

await customObservability.initialize();

// Use the logging functions anywhere
import { logInfo } from "@repo/observability/server/next";
logInfo("Application started");
```

## Available Plugins

The observability package supports multiple plugins that can be configured based
on your needs:

### Console Plugin

```typescript
import { createConsolePlugin } from "@repo/observability/plugins/console";

const consolePlugin = createConsolePlugin({
  prefix: "[MyApp]",
  enabled: true // Automatically enabled in development
});
```

### Sentry Plugin

```typescript
import { createSentryPlugin } from "@repo/observability/plugins/sentry";

const sentryPlugin = createSentryPlugin({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 0.1
});
```

### Better Stack (Logtail) Plugin

```typescript
import { createBetterStackPlugin } from "@repo/observability/plugins/betterstack";

const betterStackPlugin = createBetterStackPlugin({
  sourceToken: process.env.BETTERSTACK_SOURCE_TOKEN
});
```

### LogTape Plugin

```typescript
import { createLogTapePlugin } from "@repo/observability/plugins/logtape";

const logTapePlugin = createLogTapePlugin({
  sinks: {
    console: true,
    file: { path: "/var/log/app.log" },
    cloudwatch: {
      logGroup: "/aws/lambda/my-function",
      region: "us-east-1"
    }
  }
});
```

## Performance Monitoring

### Manual Performance Tracking

Track timing for operations using the observability manager:

```typescript
import { getObservability } from "@repo/observability/server/next";

async function loadUserData(userId: string) {
  const startTime = performance.now();
  const observability = await getObservability();

  try {
    const data = await fetchUserData(userId);
    const duration = performance.now() - startTime;

    observability.logInfo("User data loaded successfully", {
      userId,
      duration: `${duration.toFixed(2)}ms`,
      operation: "load-user-data"
    });

    return data;
  } catch (error) {
    const duration = performance.now() - startTime;

    observability.logError("Failed to load user data", {
      error,
      userId,
      duration: `${duration.toFixed(2)}ms`,
      operation: "load-user-data"
    });

    throw error;
  }
}
```

### Custom Performance Tracking

For complex operations requiring manual control:

```typescript
import { startTransaction } from "@sentry/nextjs";

// Manual performance tracking
const transaction = startTransaction({
  name: "workflow-execution",
  op: "workflow"
});

transaction.setTag("workflowType", "product-classification");
transaction.setData("productCount", products.length);

try {
  const results = await executeWorkflow(products);
  transaction.setStatus("ok");
} catch (error) {
  transaction.setStatus("internal_error");
  throw error;
} finally {
  transaction.finish();
}
```

## React Integration

### Client-Side Logging in Components

Use observability in React components:

<AccordionGroup>
  <Accordion title="Event Tracking" icon="mouse-pointer">
    ```typescript
    import { useEffect } from 'react';
    import { logInfo, logError } from '@repo/observability/client/next';

    function ProductCard({ product }) {
      const handleAddToCart = async () => {
        logInfo('Add to cart clicked', {
          productId: product.id,
          price: product.price,
          timestamp: Date.now()
        });

        try {
          const startTime = performance.now();
          await addToCart(product.id);
          const duration = performance.now() - startTime;

          logInfo('Add to cart successful', {
            productId: product.id,
            duration: `${duration.toFixed(2)}ms`
          });
        } catch (error) {
          logError('Add to cart failed', {
            error,
            productId: product.id,
            timestamp: Date.now()
          });
        }
      };

      return (
        <button onClick={handleAddToCart}>
          Add to Cart
        </button>
      );
    }
    ```

  </Accordion>

  <Accordion title="Component Lifecycle Tracking" icon="workflow">
    ```typescript
    import { useEffect } from 'react';
    import { logInfo, logError } from '@repo/observability/client/next';

    function WorkflowComponent({ workflowId }) {
      useEffect(() => {
        logInfo('Workflow component mounted', {
          workflowId,
          timestamp: Date.now()
        });

        return () => {
          logInfo('Workflow component unmounted', {
            workflowId,
            timestamp: Date.now()
          });
        };
      }, [workflowId]);

      const executeWorkflow = async () => {
        logInfo('Workflow execution started', {
          workflowId,
          triggerType: 'manual'
        });

        try {
          const result = await processWorkflow(workflowId);

          logInfo('Workflow execution completed', {
            workflowId,
            result: result.status,
            duration: result.duration
          });
        } catch (error) {
          logError('Workflow execution failed', {
            error,
            workflowId
          });
        }
      };

      return (
        <button onClick={executeWorkflow}>
          Execute Workflow
        </button>
      );
    }
    ```

  </Accordion>
</AccordionGroup>

### Workflow Analytics Integration

The observability package integrates with existing workflow systems to provide
comprehensive tracking for multi-step processes:

```typescript
// Available hooks for workflow tracking
import { useWorkflowObservability } from '@repo/observability';

function WorkflowComponent({ workflowType }: { workflowType: string }) {
  const {
    trackWorkflowEvent,
    trackWorkflowError,
    trackWorkflowPerformance
  } = useWorkflowObservability(workflowType);

  const handleWorkflowStep = async (stepName: string) => {
    const startTime = performance.now();

    try {
      trackWorkflowEvent('step-started', { stepName });

      await executeStep(stepName);

      const duration = performance.now() - startTime;
      trackWorkflowPerformance('step-execution', duration, { stepName });
      trackWorkflowEvent('step-completed', { stepName, duration });
    } catch (error) {
      trackWorkflowError(error, { stepName });
      throw error;
    }
  };

  return (
    <div>
      <button onClick={() => handleWorkflowStep('data-processing')}>
        Start Processing
      </button>
    </div>
  );
}
```

## Performance Analysis

### Custom Performance Monitoring

Use the performance timer hook for detailed timing analysis:

```typescript
import { usePerformanceTimer } from '@repo/observability';

function DataAnalysisComponent() {
  const { time, startTimer, endTimer } = usePerformanceTimer();

  const analyzeData = async (dataset: any[]) => {
    // Automatic timing with async operations
    const result = await time(
      'data-analysis',
      async () => {
        return await processLargeDataset(dataset);
      },
      { datasetSize: dataset.length }
    );

    return result;
  };

  const manualTiming = async () => {
    const transaction = startTimer('manual-operation', {
      operationType: 'custom'
    });

    try {
      await performComplexOperation();
    } finally {
      endTimer('manual-operation', {
        status: 'completed'
      });
    }
  };

  return (
    <div>
      <button onClick={() => analyzeData(largeDataset)}>
        Analyze Data
      </button>
    </div>
  );
}
```

## Advanced Configuration

### Session Replay Configuration

Session replay is automatically configured with privacy-first settings:

<Note>
  **Privacy-First Defaults:** - Mask all text content - Block media elements -
  10% sample rate - Privacy-compliant data collection
</Note>

### Custom Sampling

```typescript
// Custom error sampling (in sentry config)
beforeSend(event, hint) {
  // Filter out known non-critical errors
  if (event.exception?.values?.[0]?.type === 'ChunkLoadError') {
    return null;
  }

  // Sample high-volume errors
  if (event.tags?.component === 'HighVolumeComponent') {
    return Math.random() < 0.1 ? event : null;
  }

  return event;
}
```

### Environment Behavior

<CardGroup cols={2}>
  <Card title="Development" icon="laptop-code">
    - Console logging fallback - Optional environment variables - Reduced
    sampling rates - Local debugging support
  </Card>
  <Card title="Production" icon="server">
    - Logtail structured logging - Required environment variables - Full error
    capture and replay - Performance optimization
  </Card>
</CardGroup>

## Testing

### Mock Observability

```typescript
import { vi } from "vitest";

// Mock server-side observability
vi.mock("@repo/observability/server/next", () => ({
  logInfo: vi.fn(),
  logError: vi.fn(),
  logWarn: vi.fn(),
  logDebug: vi.fn(),
  getObservability: vi.fn(() =>
    Promise.resolve({
      logInfo: vi.fn(),
      logError: vi.fn(),
      logWarn: vi.fn(),
      logDebug: vi.fn(),
      captureException: vi.fn(),
      captureMessage: vi.fn(),
      setUser: vi.fn(),
      addBreadcrumb: vi.fn()
    })
  )
}));

// Mock client-side observability
vi.mock("@repo/observability/client/next", () => ({
  logInfo: vi.fn(),
  logError: vi.fn(),
  logWarn: vi.fn(),
  logDebug: vi.fn(),
  getObservability: vi.fn(() =>
    Promise.resolve({
      logInfo: vi.fn(),
      logError: vi.fn(),
      logWarn: vi.fn(),
      logDebug: vi.fn(),
      captureException: vi.fn(),
      captureMessage: vi.fn(),
      setUser: vi.fn(),
      addBreadcrumb: vi.fn()
    })
  )
}));

// Mock shared observability
vi.mock("@repo/observability", () => ({
  logInfo: vi.fn(),
  logError: vi.fn(),
  logWarn: vi.fn(),
  logDebug: vi.fn(),
  getRuntimeEnvironment: vi.fn(() => ({ type: "node", version: "22.0.0" }))
}));
```

## Migration Guide

### Current Logging Pattern

The observability package provides fire-and-forget logging functions that handle
async initialization internally:

<CodeGroup>
```typescript Server-Side Logging
import { logDebug, logInfo, logError } from "@repo/observability/server/next";

export async function processUser(userId: string) {
  // Fire-and-forget - no await needed
  logDebug("Starting user processing", { userId });

try { const user = await fetchUser(userId); logInfo("User fetched", { userId,
status: user.status });

    const result = await updateUser(user);
    logInfo("User updated", { userId, changes: result.changes });

    return result;

} catch (error) { // Can pass Error objects directly logError(error, { userId,
operation: 'processUser' }); // Or use error messages logError("User processing
failed", { error: error.message, userId }); throw error; } }

````

```typescript Client-Side Logging
import { logInfo, logError } from "@repo/observability/client/next";

function UserProfile({ userId }: { userId: string }) {
  const handleSave = async () => {
    logInfo("User profile save initiated", { userId });

    try {
      await saveProfile(userId);
      logInfo("User profile saved successfully", { userId });
    } catch (error) {
      logError("Failed to save user profile", { error, userId });
    }
  };

  return <button onClick={handleSave}>Save Profile</button>;
}
````

</CodeGroup>

### Key Features

1. **Fire-and-forget**: Logger functions handle async initialization internally
2. **Environment-aware**: Automatically detects and configures for the current
   runtime
3. **Plugin-based**: Supports multiple providers (Console, Sentry, BetterStack,
   LogTape)
4. **Type-safe**: Full TypeScript support with proper context typing
5. **Auto-configuration**: Works out-of-the-box based on environment variables

## Best Practices

<Warning>
  **Implementation Guidelines:** - Always provide relevant context with errors
  and logs - Use structured data for better log analysis and debugging - Include
  user/session identifiers for request tracing - Choose appropriate log levels
  (debug for development, info/error for production) - Use environment-specific
  imports for optimal bundling
</Warning>

### Recommended Patterns

1. **Structured Context**: Include relevant metadata with all log entries

   ```typescript
   logInfo("User action completed", {
     userId: user.id,
     organizationId: org.id,
     action: "profile_update",
     timestamp: Date.now(),
     userAgent: request.headers["user-agent"]
   });
   ```

2. **Error Handling**: Provide actionable error context

   ```typescript
   try {
     await criticalOperation();
   } catch (error) {
     logError(error, {
       operation: "criticalOperation",
       userId: user.id,
       retryAttempt: attemptNumber,
       duration: Date.now() - startTime
     });
   }
   ```

3. **Environment-Specific Imports**: Use the correct import for your runtime

   ```typescript
   // In Next.js server components/actions
   import { logInfo } from "@repo/observability/server/next";

   // In React client components
   import { logInfo } from "@repo/observability/client/next";

   // In middleware or edge functions
   import { logInfo } from "@repo/observability/server/edge";
   ```

4. **User Context**: Set user information for better debugging

   ```typescript
   const observability = await getObservability();
   observability.setUser({
     id: user.id,
     email: user.email,
     organizationId: org.id
   });
   ```

5. **Performance Tracking**: Monitor critical operations
   ```typescript
   const startTime = performance.now();
   try {
     const result = await expensiveOperation();
     logInfo("Operation completed", {
       operation: "expensiveOperation",
       duration: `${(performance.now() - startTime).toFixed(2)}ms`,
       resultSize: JSON.stringify(result).length
     });
   } catch (error) {
     logError("Operation failed", {
       error,
       operation: "expensiveOperation",
       duration: `${(performance.now() - startTime).toFixed(2)}ms`
     });
   }
   ```

The observability package provides comprehensive monitoring infrastructure while
maintaining simplicity and privacy-first defaults, enabling teams to understand
system behavior and user interactions across the entire Forge platform.
