---
title: "Test Factories"
description:
  "Complete guide to test data factories for generating consistent test data"
icon: "industry"
---

# Test Factories

Powerful test data factories for generating consistent, realistic test data with
relationships, sequences, and traits.

## Overview

The `@repo/qa` test factory system provides:

- **Type-safe factories** - Fully typed factory definitions with TypeScript
- **Built-in factories** - Pre-configured factories for common data models
- **Sequence generation** - Auto-incrementing sequences for unique values
- **Trait support** - Variations and modifications to base factory data
- **Relationship handling** - Automatic creation of related entities
- **Batch creation** - Efficient creation of multiple entities

## Quick Start

### Basic Factory Usage

```typescript
// Import factory functions
import {
  userFactory,
  productFactory,
  orderFactory,
  createMany
} from "@repo/qa/vitest/factories";

test("creates test users", () => {
  // Create single user
  const user = userFactory.create();
  expect(user).toMatchObject({
    id: expect.any(String),
    name: expect.any(String),
    email: expect.stringMatching(/@/),
    createdAt: expect.any(Date)
  });

  // Create user with specific attributes
  const adminUser = userFactory.create({
    role: "admin",
    email: "admin@example.com"
  });
  expect(adminUser.role).toBe("admin");
  expect(adminUser.email).toBe("admin@example.com");
});

test("creates multiple entities", () => {
  // Create multiple users
  const users = userFactory.createMany(5);
  expect(users).toHaveLength(5);

  // Each user has unique attributes
  const emails = users.map((u) => u.email);
  const uniqueEmails = new Set(emails);
  expect(uniqueEmails.size).toBe(5);
});
```

### Advanced Factory Usage

```typescript
test("creates related data", () => {
  // Create user with orders
  const userWithOrders = userFactory.create({
    orders: orderFactory.createMany(3)
  });

  expect(userWithOrders.orders).toHaveLength(3);
  expect(userWithOrders.orders[0]).toMatchObject({
    id: expect.any(String),
    userId: userWithOrders.id,
    total: expect.any(Number)
  });
});

test("uses factory traits", () => {
  // Create premium user
  const premiumUser = userFactory.create({ trait: "premium" });
  expect(premiumUser.subscription).toBe("premium");
  expect(premiumUser.features).toContain("advanced_analytics");

  // Create inactive user
  const inactiveUser = userFactory.create({ trait: "inactive" });
  expect(inactiveUser.status).toBe("inactive");
  expect(inactiveUser.lastLoginAt).toBeNull();
});
```

## Built-in Factories

### User Factory

```typescript
import { userFactory } from "@repo/qa/vitest/factories";

// Basic user creation
const user = userFactory.create();
// Result: { id, name, email, role, createdAt, updatedAt }

// User with specific attributes
const adminUser = userFactory.create({
  name: "Admin User",
  email: "admin@company.com",
  role: "admin"
});

// User traits
const premiumUser = userFactory.create({ trait: "premium" });
const inactiveUser = userFactory.create({ trait: "inactive" });
const newUser = userFactory.create({ trait: "new" });

// Available traits for users:
// - premium: subscription: "premium", features: advanced features
// - inactive: status: "inactive", lastLoginAt: null
// - new: createdAt: recent, emailVerified: false
// - admin: role: "admin", permissions: all permissions
```

### Product Factory

```typescript
import { productFactory } from "@repo/qa/vitest/factories";

// Basic product
const product = productFactory.create();
// Result: { id, name, description, price, sku, categoryId, createdAt }

// Product with specific price
const expensiveProduct = productFactory.create({
  price: 99.99,
  name: "Premium Product"
});

// Product traits
const digitalProduct = productFactory.create({ trait: "digital" });
const outOfStockProduct = productFactory.create({ trait: "out_of_stock" });
const featuredProduct = productFactory.create({ trait: "featured" });

// Available traits for products:
// - digital: type: "digital", shipping: false, downloadUrl: present
// - out_of_stock: stock: 0, status: "out_of_stock"
// - featured: featured: true, priority: high
// - on_sale: salePrice: discounted, onSale: true
```

### Organization Factory

```typescript
import { organizationFactory } from "@repo/qa/vitest/factories";

// Basic organization
const org = organizationFactory.create();
// Result: { id, name, slug, plan, memberCount, createdAt }

// Organization with members
const orgWithMembers = organizationFactory.create({
  members: userFactory.createMany(5)
});

// Organization traits
const enterpriseOrg = organizationFactory.create({ trait: "enterprise" });
const startupOrg = organizationFactory.create({ trait: "startup" });

// Available traits for organizations:
// - enterprise: plan: "enterprise", memberLimit: 1000, features: all
// - startup: plan: "startup", memberLimit: 10, features: basic
// - trial: plan: "trial", expiresAt: soon, features: limited
```

### Order Factory

```typescript
import { orderFactory } from "@repo/qa/vitest/factories";

// Basic order
const order = orderFactory.create();
// Result: { id, userId, total, status, items, createdAt }

// Order with specific items
const orderWithItems = orderFactory.create({
  items: [
    { productId: "prod1", quantity: 2, price: 29.99 },
    { productId: "prod2", quantity: 1, price: 49.99 }
  ]
});

// Order traits
const completedOrder = orderFactory.create({ trait: "completed" });
const cancelledOrder = orderFactory.create({ trait: "cancelled" });
const pendingOrder = orderFactory.create({ trait: "pending" });

// Available traits for orders:
// - completed: status: "completed", completedAt: recent, paymentStatus: "paid"
// - cancelled: status: "cancelled", cancelledAt: recent, refundStatus: "refunded"
// - pending: status: "pending", paymentStatus: "pending"
// - shipped: status: "shipped", shippedAt: recent, trackingNumber: present
```

## Custom Factories

### Creating Custom Factories

```typescript
import { createFactory, Factory } from "@repo/qa/vitest/factories";

// Define your data type
interface BlogPost {
  id: string;
  title: string;
  content: string;
  authorId: string;
  publishedAt: Date | null;
  tags: string[];
  status: "draft" | "published" | "archived";
}

// Create factory
const blogPostFactory = createFactory<BlogPost>({
  id: () => generateId(),
  title: (sequence) => `Blog Post ${sequence}`,
  content: () => generateLoremIpsum(500),
  authorId: () => userFactory.create().id,
  publishedAt: null,
  tags: () => ["technology", "programming"],
  status: "draft"
});

// Use custom factory
test("creates blog posts", () => {
  const post = blogPostFactory.create();
  expect(post.title).toMatch(/Blog Post \d+/);
  expect(post.status).toBe("draft");

  const publishedPost = blogPostFactory.create({
    status: "published",
    publishedAt: new Date()
  });
  expect(publishedPost.status).toBe("published");
});
```

### Factory with Traits

```typescript
const blogPostFactory = createFactory<BlogPost>(
  {
    // ... base definition
  },
  {
    traits: {
      published: {
        status: "published",
        publishedAt: () => new Date(),
        tags: ["featured", "published"]
      },

      draft: {
        status: "draft",
        publishedAt: null,
        tags: ["draft"]
      },

      popular: {
        tags: ["popular", "trending"],
        viewCount: () => randomNumber(1000, 10000),
        likes: () => randomNumber(100, 1000)
      }
    }
  }
);

test("uses blog post traits", () => {
  const publishedPost = blogPostFactory.create({ trait: "published" });
  expect(publishedPost.status).toBe("published");
  expect(publishedPost.publishedAt).toBeInstanceOf(Date);

  const popularPost = blogPostFactory.create({ trait: "popular" });
  expect(popularPost.tags).toContain("popular");
  expect(popularPost.viewCount).toBeGreaterThan(1000);
});
```

### Factory with Relationships

```typescript
interface Comment {
  id: string;
  content: string;
  authorId: string;
  postId: string;
  createdAt: Date;
  replies?: Comment[];
}

const commentFactory = createFactory<Comment>({
  id: () => generateId(),
  content: (sequence) => `Comment content ${sequence}`,
  authorId: () => userFactory.create().id,
  postId: () => blogPostFactory.create().id,
  createdAt: () => new Date(),
  replies: []
});

// Create comment with nested replies
test("creates nested comments", () => {
  const parentComment = commentFactory.create({
    replies: commentFactory.createMany(3, {
      postId: "same-post-id" // All replies on same post
    })
  });

  expect(parentComment.replies).toHaveLength(3);
  expect(parentComment.replies?.[0].postId).toBe("same-post-id");
});
```

## Advanced Patterns

### Sequence Generation

```typescript
import { createSequence, resetSequence } from "@repo/qa/vitest/factories";

// Create custom sequences
const emailSequence = createSequence((n) => `user${n}@example.com`);
const skuSequence = createSequence(
  (n) => `SKU-${n.toString().padStart(6, "0")}`
);

const productFactory = createFactory<Product>({
  sku: skuSequence,
  email: emailSequence
  // ... other fields
});

test("generates sequential values", () => {
  resetSequence(); // Reset to start from 1

  const products = productFactory.createMany(3);
  expect(products[0].sku).toBe("SKU-000001");
  expect(products[1].sku).toBe("SKU-000002");
  expect(products[2].sku).toBe("SKU-000003");
});
```

### Factory Inheritance

```typescript
// Base user factory
const baseUserFactory = createFactory<User>({
  id: () => generateId(),
  name: (sequence) => `User ${sequence}`,
  email: (sequence) => `user${sequence}@example.com`,
  role: "user"
});

// Admin user factory inheriting from base
const adminUserFactory = createFactory<User>({
  ...baseUserFactory.definition,
  role: "admin",
  permissions: () => ["read", "write", "delete"],
  adminSince: () => new Date()
});

test("uses factory inheritance", () => {
  const admin = adminUserFactory.create();
  expect(admin.role).toBe("admin");
  expect(admin.permissions).toContain("delete");
  expect(admin.name).toMatch(/User \d+/); // Inherited from base
});
```

### Conditional Factory Logic

```typescript
const orderFactory = createFactory<Order>({
  id: () => generateId(),
  status: "pending",
  total: () => randomNumber(10, 1000),

  // Conditional fields based on other fields
  completedAt: (sequence, attributes) =>
    attributes.status === "completed" ? new Date() : null,

  refundAmount: (sequence, attributes) =>
    attributes.status === "refunded" ? attributes.total : 0,

  trackingNumber: (sequence, attributes) =>
    attributes.status === "shipped" ? generateTrackingNumber() : null
});

test("handles conditional logic", () => {
  const completedOrder = orderFactory.create({ status: "completed" });
  expect(completedOrder.completedAt).toBeInstanceOf(Date);

  const pendingOrder = orderFactory.create({ status: "pending" });
  expect(pendingOrder.completedAt).toBeNull();
});
```

## Database Integration

### Factory with Database Persistence

```typescript
import { db } from "@repo/database/prisma/server/next";

// Create factory that persists to database
const persistentUserFactory = createFactory<User>(
  {
    // ... factory definition
  },
  {
    async afterCreate(user) {
      // Save to database after creation
      return await db.user.create({ data: user });
    },

    async afterCreateMany(users) {
      // Batch save to database
      return await db.user.createMany({ data: users });
    }
  }
);

test("creates users in database", async () => {
  const user = await persistentUserFactory.create();

  // Verify user exists in database
  const dbUser = await db.user.findUnique({ where: { id: user.id } });
  expect(dbUser).toBeTruthy();
  expect(dbUser?.email).toBe(user.email);
});
```

### Factory with Database Cleanup

```typescript
// Track created entities for cleanup
let createdEntities: { table: string; id: string }[] = [];

const trackingUserFactory = createFactory<User>(
  {
    // ... factory definition
  },
  {
    async afterCreate(user) {
      const dbUser = await db.user.create({ data: user });
      createdEntities.push({ table: "user", id: dbUser.id });
      return dbUser;
    }
  }
);

afterEach(async () => {
  // Cleanup created entities
  for (const entity of createdEntities.reverse()) {
    if (entity.table === "user") {
      await db.user.delete({ where: { id: entity.id } });
    }
    // Add other tables as needed
  }
  createdEntities = [];
});
```

## Performance Optimization

### Efficient Batch Creation

```typescript
import { createManyOptimized } from "@repo/qa/vitest/factories";

test("efficiently creates large datasets", async () => {
  // Regular creation (slower)
  const users1 = userFactory.createMany(1000);

  // Optimized batch creation (faster)
  const users2 = await createManyOptimized(userFactory, 1000, {
    batchSize: 100, // Process in batches of 100
    parallel: true // Process batches in parallel
  });

  expect(users2).toHaveLength(1000);
});
```

### Factory Caching

```typescript
import { createCachedFactory } from "@repo/qa/vitest/factories";

// Cache expensive computations
const expensiveDataFactory = createCachedFactory<ExpensiveData>(
  {
    id: () => generateId(),
    complexCalculation: () => performExpensiveCalculation(), // Cached
    dynamicValue: () => Math.random() // Not cached
  },
  {
    cacheKeys: ["complexCalculation"] // Only cache specific fields
  }
);

test("uses cached values", () => {
  const data1 = expensiveDataFactory.create();
  const data2 = expensiveDataFactory.create();

  // Complex calculation result is same (cached)
  expect(data1.complexCalculation).toBe(data2.complexCalculation);

  // Dynamic value is different (not cached)
  expect(data1.dynamicValue).not.toBe(data2.dynamicValue);
});
```

## Testing Patterns

### Factory Testing

```typescript
describe("Factory System", () => {
  test("validates factory output", () => {
    const users = userFactory.createMany(100);

    // Verify all users have required fields
    users.forEach((user) => {
      expect(user.id).toBeTruthy();
      expect(user.email).toMatch(/@/);
      expect(user.createdAt).toBeInstanceOf(Date);
    });

    // Verify uniqueness
    const emails = users.map((u) => u.email);
    const uniqueEmails = new Set(emails);
    expect(uniqueEmails.size).toBe(100);
  });

  test("factory traits work correctly", () => {
    const premiumUser = userFactory.create({ trait: "premium" });
    const basicUser = userFactory.create({ trait: "basic" });

    expect(premiumUser.subscription).toBe("premium");
    expect(basicUser.subscription).toBe("basic");
    expect(premiumUser.features.length).toBeGreaterThan(
      basicUser.features.length
    );
  });
});
```

### Integration Testing with Factories

```typescript
test("complete user workflow", async () => {
  // Create test data
  const user = userFactory.create();
  const products = productFactory.createMany(3);
  const cart = cartFactory.create({
    userId: user.id,
    items: products.map((p) => ({ productId: p.id, quantity: 1 }))
  });

  // Test workflow
  const order = await processCheckout(cart);
  expect(order.userId).toBe(user.id);
  expect(order.items).toHaveLength(3);
  expect(order.status).toBe("pending");

  // Verify order processing
  const completedOrder = await completeOrder(order.id);
  expect(completedOrder.status).toBe("completed");
});
```

## Best Practices

### Factory Organization

```typescript
// Organize factories by domain
export const userFactories = {
  user: userFactory,
  admin: adminUserFactory,
  customer: customerFactory
};

export const productFactories = {
  product: productFactory,
  digital: digitalProductFactory,
  physical: physicalProductFactory
};

export const orderFactories = {
  order: orderFactory,
  subscription: subscriptionOrderFactory,
  refund: refundFactory
};
```

### Type Safety

```typescript
// Use strict typing for factory definitions
interface StrictUser {
  readonly id: string;
  readonly email: string;
  readonly name: string;
  readonly role: "admin" | "user" | "moderator";
  readonly createdAt: Date;
}

const strictUserFactory = createFactory<StrictUser>({
  id: () => generateId(),
  email: (sequence) => `user${sequence}@example.com`,
  name: (sequence) => `User ${sequence}`,
  role: "user" as const, // Explicit type
  createdAt: () => new Date()
});

// TypeScript will catch invalid attributes
test("type safety", () => {
  const user = strictUserFactory.create({
    role: "admin" // ✅ Valid
    // role: "invalid" // ❌ TypeScript error
  });
});
```

### Factory Documentation

````typescript
/**
 * User Factory
 *
 * Creates test user data with realistic attributes.
 *
 * @example
 * ```typescript
 * // Basic user
 * const user = userFactory.create();
 *
 * // Admin user
 * const admin = userFactory.create({ trait: "admin" });
 *
 * // Multiple users
 * const users = userFactory.createMany(10);
 * ```
 *
 * Available traits:
 * - admin: Full permissions, admin role
 * - premium: Premium subscription, advanced features
 * - inactive: Inactive status, no recent login
 * - new: Recently created, unverified email
 */
export const userFactory = createFactory<User>({
  // Factory definition...
});
````

Test factories provide a powerful, type-safe way to generate consistent test
data while maintaining flexibility for different testing scenarios. They
significantly reduce boilerplate code and improve test maintainability.
