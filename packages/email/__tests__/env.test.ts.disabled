import { afterEach, beforeEach, describe, expect, vi } from 'vitest';

// Mock environment variables
const mockCreateEnv = vi.fn();
vi.mock('@t3-oss/env-nextjs', () => ({
  createEnv: mockCreateEnv,
}));

describe('email Environment Configuration', () => {
  let originalEnv: NodeJS.ProcessEnv;

  beforeEach(() => {
    originalEnv = { ...process.env };
    vi.clearAllMocks();
    vi.resetModules();
  });

  afterEach(() => {
    process.env = originalEnv;
  });

  describe('production environment', () => {
    beforeEach(() => {
      process.env.NODE_ENV = 'production';
      process.env.RESEND_FROM = 'noreply@example.com';
      process.env.RESEND_TOKEN = 're_123456789';
    });

    test('should require valid Resend keys in production', async () => {
      mockCreateEnv.mockReturnValue({
        RESEND_FROM: 'noreply@example.com',
        RESEND_TOKEN: 're_123456789',
      });

      const { safeEnv } = await import('../env');
      const result = safeEnv();

      expect(mockCreateEnv).toHaveBeenCalledWith({
        runtimeEnv: {
          RESEND_FROM: 'noreply@example.com',
          RESEND_TOKEN: 're_123456789',
        },
        server: {
          RESEND_FROM: expect.objectContaining({
            def: expect.objectContaining({
              type: 'string',
            }),
          }),
          RESEND_TOKEN: expect.objectContaining({
            def: expect.objectContaining({
              type: 'string',
            }),
          }),
        },
      });

      expect(result.RESEND_FROM).toBe('noreply@example.com');
      expect(result.RESEND_TOKEN).toBe('re_123456789');
    });

    test('should validate email format for RESEND_FROM in production', async () => {
      const { safeEnv } = await import('../env');

      // The actual validation happens in @t3-oss/env-nextjs
      // We just verify our schema configuration is correct
      safeEnv();

      const call = mockCreateEnv.mock.calls[0][0];
      expect(call.server.RESEND_FROM).toBeDefined();

      // Check that it's an email validation schema by testing it
      const fromSchema = call.server.RESEND_FROM;
      expect(fromSchema.def.type).toBe('string');
      expect(fromSchema.def.checks).toHaveLength(1);
      expect(() => fromSchema.parse('test@example.com')).not.toThrow();
      expect(() => fromSchema.parse('invalid-email')).toThrow('Invalid email format');
    });

    test('should validate token format for RESEND_TOKEN in production', async () => {
      const { safeEnv } = await import('../env');
      safeEnv();

      const call = mockCreateEnv.mock.calls[0][0];
      expect(call.server.RESEND_TOKEN).toBeDefined();

      // Check that it validates startsWith 're_' by testing it
      const tokenSchema = call.server.RESEND_TOKEN;
      expect(tokenSchema.def.type).toBe('string');
      expect(tokenSchema.def.checks).toHaveLength(1);
      expect(() => tokenSchema.parse('re_123456789')).not.toThrow();
      expect(() => tokenSchema.parse('invalid_token')).toThrow('Invalid token format');
    });
  });

  describe('development environment', () => {
    beforeEach(() => {
      process.env.NODE_ENV = 'development';
      process.env.RESEND_FROM = 'dev@example.com';
      process.env.RESEND_TOKEN = 're_dev_123456789';
    });

    test('should make keys optional in development', async () => {
      mockCreateEnv.mockReturnValue({
        RESEND_FROM: 'dev@example.com',
        RESEND_TOKEN: 're_dev_123456789',
      });

      const { safeEnv } = await import('../env');
      const result = safeEnv();

      expect(result.RESEND_FROM).toBe('dev@example.com');
      expect(result.RESEND_TOKEN).toBe('re_dev_123456789');
    });

    test('should handle missing keys in development', async () => {
      process.env.RESEND_FROM = undefined;
      process.env.RESEND_TOKEN = undefined;

      mockCreateEnv.mockReturnValue({
        RESEND_FROM: undefined,
        RESEND_TOKEN: undefined,
      });

      const { safeEnv } = await import('../env');
      const result = safeEnv();

      expect(mockCreateEnv).toHaveBeenCalledWith({
        runtimeEnv: {
          RESEND_FROM: undefined,
          RESEND_TOKEN: undefined,
        },
        server: {
          RESEND_FROM: expect.objectContaining({
            def: expect.objectContaining({
              type: 'optional',
            }),
          }),
          RESEND_TOKEN: expect.objectContaining({
            def: expect.objectContaining({
              type: 'optional',
            }),
          }),
        },
      });

      expect(result.RESEND_FROM).toBeUndefined();
      expect(result.RESEND_TOKEN).toBeUndefined();
    });
  });

  describe('production with missing required env vars', () => {
    beforeEach(() => {
      process.env.NODE_ENV = 'production';
      // Missing required env vars
      process.env.RESEND_FROM = undefined;
      process.env.RESEND_TOKEN = undefined;
    });

    test('should make keys optional when env vars are missing in production', async () => {
      mockCreateEnv.mockReturnValue({
        RESEND_FROM: undefined,
        RESEND_TOKEN: undefined,
      });

      const { safeEnv } = await import('../env');
      const result = safeEnv();

      // When hasRequiredEnvVars is false, keys become optional even in production
      expect(mockCreateEnv).toHaveBeenCalledWith({
        runtimeEnv: {
          RESEND_FROM: undefined,
          RESEND_TOKEN: undefined,
        },
        server: {
          RESEND_FROM: expect.objectContaining({
            def: expect.objectContaining({
              type: 'optional',
            }),
          }),
          RESEND_TOKEN: expect.objectContaining({
            def: expect.objectContaining({
              type: 'optional',
            }),
          }),
        },
      });

      expect(result.RESEND_FROM).toBeUndefined();
      expect(result.RESEND_TOKEN).toBeUndefined();
    });
  });

  describe('environment variable validation', () => {
    beforeEach(() => {
      process.env.NODE_ENV = 'production';
      process.env.RESEND_FROM = 'test@example.com';
      process.env.RESEND_TOKEN = 're_test_123456789';
    });

    test('should validate email format', async () => {
      const { safeEnv } = await import('../env');
      safeEnv();

      const call = mockCreateEnv.mock.calls[0][0];
      const fromSchema = call.server.RESEND_FROM;

      // The schema should validate email format by testing it
      expect(fromSchema.def.type).toBe('string');
      expect(fromSchema.def.checks).toHaveLength(1);
      expect(() => fromSchema.parse('test@example.com')).not.toThrow();
      expect(() => fromSchema.parse('invalid-email')).toThrow('Invalid email format');
    });

    test('should validate token prefix', async () => {
      const { safeEnv } = await import('../env');
      safeEnv();

      const call = mockCreateEnv.mock.calls[0][0];
      const tokenSchema = call.server.RESEND_TOKEN;

      // The schema should validate that the token starts with 're_' by testing it
      expect(tokenSchema.def.type).toBe('string');
      expect(tokenSchema.def.checks).toHaveLength(1);
      expect(() => tokenSchema.parse('re_123456789')).not.toThrow();
      expect(() => tokenSchema.parse('invalid_token')).toThrow('Invalid token format');
    });
  });

  describe('runtime environment mapping', () => {
    beforeEach(() => {
      process.env.NODE_ENV = 'development';
      process.env.RESEND_FROM = 'test@example.com';
      process.env.RESEND_TOKEN = 're_test_123456789';
    });

    test('should map environment variables correctly', async () => {
      const { safeEnv } = await import('../env');
      safeEnv();

      expect(mockCreateEnv).toHaveBeenCalledWith({
        runtimeEnv: {
          RESEND_FROM: 'test@example.com',
          RESEND_TOKEN: 're_test_123456789',
        },
        server: expect.any(Object),
      });
    });

    test('should handle undefined environment variables', async () => {
      process.env.RESEND_FROM = undefined;
      process.env.RESEND_TOKEN = undefined;

      const { safeEnv } = await import('../env');
      safeEnv();

      expect(mockCreateEnv).toHaveBeenCalledWith({
        runtimeEnv: {
          RESEND_FROM: undefined,
          RESEND_TOKEN: undefined,
        },
        server: expect.any(Object),
      });
    });

    test('should handle empty string environment variables', async () => {
      process.env.RESEND_FROM = '';
      process.env.RESEND_TOKEN = '';

      const { safeEnv } = await import('../env');
      safeEnv();

      expect(mockCreateEnv).toHaveBeenCalledWith({
        runtimeEnv: {
          RESEND_FROM: undefined,
          RESEND_TOKEN: undefined,
        },
        server: expect.any(Object),
      });
    });
  });

  describe('configuration logic', () => {
    test('should determine requireInProduction correctly for production with keys', async () => {
      process.env.NODE_ENV = 'production';
      process.env.RESEND_FROM = 'prod@example.com';
      process.env.RESEND_TOKEN = 're_prod_123';

      const { safeEnv } = await import('../env');
      safeEnv();

      // Should require keys in production when they exist
      const call = mockCreateEnv.mock.calls[0][0];
      expect(call.server.RESEND_FROM._def.typeName).not.toBe('ZodOptional');
      expect(call.server.RESEND_TOKEN._def.typeName).not.toBe('ZodOptional');
    });

    test('should determine requireInProduction correctly for production without keys', async () => {
      process.env.NODE_ENV = 'production';
      process.env.RESEND_FROM = undefined;
      process.env.RESEND_TOKEN = undefined;

      const { safeEnv } = await import('../env');
      safeEnv();

      // Should make keys optional in production when they don't exist
      const call = mockCreateEnv.mock.calls[0][0];
      expect(call.server.RESEND_FROM.def.type).toBe('optional');
      expect(call.server.RESEND_TOKEN.def.type).toBe('optional');
    });

    test('should determine requireInProduction correctly for development', async () => {
      process.env.NODE_ENV = 'development';
      process.env.RESEND_FROM = 'dev@example.com';
      process.env.RESEND_TOKEN = 're_dev_123';

      const { safeEnv } = await import('../env');
      safeEnv();

      // Should make keys optional in development regardless of existence
      const call = mockCreateEnv.mock.calls[0][0];
      expect(call.server.RESEND_FROM.def.type).toBe('optional');
      expect(call.server.RESEND_TOKEN.def.type).toBe('optional');
    });

    test('should handle partial env vars correctly', async () => {
      process.env.NODE_ENV = 'production';
      process.env.RESEND_FROM = 'test@example.com';
      process.env.RESEND_TOKEN = undefined; // Missing one required var

      const { safeEnv } = await import('../env');
      safeEnv();

      // Should make keys optional when not all are present
      const call = mockCreateEnv.mock.calls[0][0];
      expect(call.server.RESEND_FROM.def.type).toBe('optional');
      expect(call.server.RESEND_TOKEN.def.type).toBe('optional');
    });
  });

  describe('error handling', () => {
    beforeEach(() => {
      process.env.NODE_ENV = 'production';
      process.env.RESEND_FROM = 'test@example.com';
      process.env.RESEND_TOKEN = 're_test_123456789';
    });

    test('should propagate createEnv errors', async () => {
      const error = new Error('Invalid environment configuration');
      mockCreateEnv.mockImplementation(() => {
        throw error;
      });

      const { safeEnv } = await import('../env');

      expect(() => safeEnv()).toThrow('Invalid environment configuration');
    });
  });

  describe('function invocation', () => {
    beforeEach(() => {
      process.env.NODE_ENV = 'development';
      process.env.RESEND_FROM = 'test@example.com';
      process.env.RESEND_TOKEN = 're_test_123456789';

      mockCreateEnv.mockReturnValue({
        RESEND_FROM: 'test@example.com',
        RESEND_TOKEN: 're_test_123456789',
      });
    });

    test('should return a function', async () => {
      const { safeEnv } = await import('../env');
      expect(typeof safeEnv).toBe('function');
    });

    test('should call createEnv when invoked', async () => {
      const { safeEnv } = await import('../env');
      safeEnv();

      expect(mockCreateEnv).toHaveBeenCalledTimes(1);
    });

    test('should return the result from createEnv', async () => {
      const expectedResult = {
        RESEND_FROM: 'test@example.com',
        RESEND_TOKEN: 're_test_123456789',
      };

      mockCreateEnv.mockReturnValue(expectedResult);

      const { safeEnv } = await import('../env');
      const result = safeEnv();

      expect(result).toStrictEqual(expectedResult);
    });

    test('should call createEnv every time invoked', async () => {
      const { safeEnv } = await import('../env');

      safeEnv();
      safeEnv();
      safeEnv();

      expect(mockCreateEnv).toHaveBeenCalledTimes(3);
    });
  });

  describe('hasRequiredEnvVars logic', () => {
    test('should detect when both env vars are present', async () => {
      process.env.NODE_ENV = 'production';
      process.env.RESEND_FROM = 'test@example.com';
      process.env.RESEND_TOKEN = 're_test_123';

      const { safeEnv } = await import('../env');
      safeEnv();

      // Both present = requireInProduction = true = not optional
      const call = mockCreateEnv.mock.calls[0][0];
      expect(call.server.RESEND_FROM._def.typeName).not.toBe('ZodOptional');
    });

    test('should detect when one env var is missing', async () => {
      process.env.NODE_ENV = 'production';
      process.env.RESEND_FROM = 'test@example.com';
      process.env.RESEND_TOKEN = undefined;

      const { safeEnv } = await import('../env');
      safeEnv();

      // One missing = requireInProduction = false = optional
      const call = mockCreateEnv.mock.calls[0][0];
      expect(call.server.RESEND_FROM.def.type).toBe('optional');
    });

    test('should detect when both env vars are missing', async () => {
      process.env.NODE_ENV = 'production';
      process.env.RESEND_FROM = undefined;
      process.env.RESEND_TOKEN = undefined;

      const { safeEnv } = await import('../env');
      safeEnv();

      // Both missing = requireInProduction = false = optional
      const call = mockCreateEnv.mock.calls[0][0];
      expect(call.server.RESEND_FROM.def.type).toBe('optional');
      expect(call.server.RESEND_TOKEN.def.type).toBe('optional');
    });
  });
});
