import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';

// Mock environment variables in process.env
const mockProcessEnv = (envVars: Record<string, string | undefined>) => {
  vi.stubEnv('NODE_ENV', envVars.NODE_ENV || 'test');
  vi.stubEnv('LOG_LEVEL', envVars.LOG_LEVEL || 'info');
  vi.stubEnv('OBSERVABILITY_CONSOLE_ENABLED', envVars.OBSERVABILITY_CONSOLE_ENABLED || 'true');
  vi.stubEnv('OBSERVABILITY_SENTRY_ENABLED', envVars.OBSERVABILITY_SENTRY_ENABLED || 'false');
  vi.stubEnv('OBSERVABILITY_OTEL_ENABLED', envVars.OBSERVABILITY_OTEL_ENABLED || 'false');
  vi.stubEnv('OBSERVABILITY_LOGTAIL_ENABLED', envVars.OBSERVABILITY_LOGTAIL_ENABLED || 'false');
  vi.stubEnv('OBSERVABILITY_GRAFANA_ENABLED', envVars.OBSERVABILITY_GRAFANA_ENABLED || 'false');
  vi.stubEnv('NEXT_RUNTIME', envVars.NEXT_RUNTIME || 'nodejs');
  vi.stubEnv('NEXT_PUBLIC_NODE_ENV', envVars.NEXT_PUBLIC_NODE_ENV || 'test');
  vi.stubEnv('NEXT_PUBLIC_ENABLE_CLIENT_LOGGING', envVars.NEXT_PUBLIC_ENABLE_CLIENT_LOGGING || 'false');
};

describe('environment utilities', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.unstubAllEnvs();
    // Set default test environment
    mockProcessEnv({});
  });

  afterEach(() => {
    vi.unstubAllEnvs();
  });

  describe('safeEnv', () => {
    test('should return environment variables', async () => {
      mockProcessEnv({
        NODE_ENV: 'test',
        OBSERVABILITY_CONSOLE_ENABLED: 'true',
        NEXT_PUBLIC_NODE_ENV: 'test',
        NEXT_PUBLIC_ENABLE_CLIENT_LOGGING: 'false',
      });

      const { safeEnv } = await import('../env');
      const env = safeEnv();

      expect(env).toBeDefined();
      expect(typeof env.NODE_ENV).toBe('string');
      expect(['development', 'production', 'test']).toContain(env.NODE_ENV);
      expect(typeof env.OBSERVABILITY_CONSOLE_ENABLED).toBe('boolean');
      expect(typeof env.NEXT_PUBLIC_NODE_ENV).toBe('string');
      expect(typeof env.NEXT_PUBLIC_ENABLE_CLIENT_LOGGING).toBe('boolean');
    });

    test('should have reasonable defaults', async () => {
      mockProcessEnv({});

      const { safeEnv } = await import('../env');
      const env = safeEnv();

      expect(['development', 'test']).toContain(env.NODE_ENV);
      expect(env.LOG_LEVEL).toBe('info');
      expect(env.OBSERVABILITY_CONSOLE_ENABLED).toBeTruthy();
      expect(env.OBSERVABILITY_SENTRY_ENABLED).toBeFalsy();
      expect(['development', 'test']).toContain(env.NEXT_PUBLIC_NODE_ENV);
      expect(env.NEXT_PUBLIC_ENABLE_CLIENT_LOGGING).toBeFalsy();
    });
  });

  describe('getRawEnv', () => {
    test('should return process.env object', async () => {
      const { getRawEnv } = await import('../env');
      const rawEnv = getRawEnv();

      expect(rawEnv).toBeDefined();
      expect(typeof rawEnv).toBe('object');
    });

    test('should handle missing process gracefully', async () => {
      const originalProcess = global.process;
      // @ts-ignore
      delete global.process;

      const { getRawEnv } = await import('../env');
      const rawEnv = getRawEnv();

      expect(rawEnv).toStrictEqual({});

      global.process = originalProcess;
    });
  });

  describe('environment detection', () => {
    test('should detect test environment', async () => {
      mockProcessEnv({ NODE_ENV: 'test' });

      const { isTest, isProduction, isDevelopment } = await import('../env');

      expect(isTest()).toBeTruthy();
      expect(isProduction()).toBeFalsy();
      expect(isDevelopment()).toBeFalsy();
    });

    test('should detect production environment', async () => {
      mockProcessEnv({ NODE_ENV: 'production' });

      const { isTest, isProduction, isDevelopment } = await import('../env');

      expect(isProduction()).toBeTruthy();
      expect(isTest()).toBeFalsy();
      expect(isDevelopment()).toBeFalsy();
    });

    test('should detect development environment', async () => {
      mockProcessEnv({ NODE_ENV: 'development' });

      const { isTest, isProduction, isDevelopment } = await import('../env');

      expect(isDevelopment()).toBeTruthy();
      expect(isTest()).toBeFalsy();
      expect(isProduction()).toBeFalsy();
    });
  });

  describe('runtime detection', () => {
    test('should detect node runtime', async () => {
      mockProcessEnv({ NEXT_RUNTIME: 'nodejs' });

      const { isNodeRuntime, isEdgeRuntime } = await import('../env');

      expect(isNodeRuntime()).toBeTruthy();
      expect(isEdgeRuntime()).toBeFalsy();
    });

    test('should detect edge runtime', async () => {
      mockProcessEnv({ NEXT_RUNTIME: 'edge' });

      const { isNodeRuntime, isEdgeRuntime } = await import('../env');

      expect(isEdgeRuntime()).toBeTruthy();
      expect(isNodeRuntime()).toBeFalsy();
    });

    test('should default to node runtime when NEXT_RUNTIME is not set', async () => {
      mockProcessEnv({ NEXT_RUNTIME: undefined });

      const { isNodeRuntime, isEdgeRuntime } = await import('../env');

      expect(isNodeRuntime()).toBeTruthy();
      expect(isEdgeRuntime()).toBeFalsy();
    });
  });

  describe('platform detection', () => {
    test('should detect Vercel environment', async () => {
      vi.stubEnv('VERCEL_ENV', 'preview');

      const { isVercelEnvironment } = await import('../env');

      expect(isVercelEnvironment()).toBeTruthy();
    });

    test('should detect non-Vercel environment', async () => {
      vi.stubEnv('VERCEL_ENV', undefined);

      const { isVercelEnvironment } = await import('../env');

      expect(isVercelEnvironment()).toBeFalsy();
    });

    test('should detect build environment with CI', async () => {
      vi.stubEnv('CI', 'true');

      const { isBuildEnvironment } = await import('../env');

      expect(isBuildEnvironment()).toBeTruthy();
    });

    test('should detect build environment with VERCEL', async () => {
      vi.stubEnv('VERCEL', '1');

      const { isBuildEnvironment } = await import('../env');

      expect(isBuildEnvironment()).toBeTruthy();
    });

    test('should detect build environment with BUILDING_CONTAINER', async () => {
      vi.stubEnv('BUILDING_CONTAINER', 'true');

      const { isBuildEnvironment } = await import('../env');

      expect(isBuildEnvironment()).toBeTruthy();
    });
  });

  describe('feature flags', () => {
    test('should read console enabled flag', async () => {
      mockProcessEnv({ OBSERVABILITY_CONSOLE_ENABLED: 'true' });

      const { isConsoleEnabled } = await import('../env');

      expect(typeof isConsoleEnabled()).toBe('boolean');
      expect(isConsoleEnabled()).toBeTruthy();
    });

    test('should read console disabled flag', async () => {
      mockProcessEnv({ OBSERVABILITY_CONSOLE_ENABLED: 'false' });

      const { isConsoleEnabled } = await import('../env');

      expect(typeof isConsoleEnabled()).toBe('boolean');
      expect(isConsoleEnabled()).toBeFalsy();
    });

    test('should read Sentry enabled flag', async () => {
      mockProcessEnv({ OBSERVABILITY_SENTRY_ENABLED: 'true' });

      const { isSentryEnabled } = await import('../env');

      expect(typeof isSentryEnabled()).toBe('boolean');
      expect(isSentryEnabled()).toBeTruthy();
    });

    test('should read Sentry disabled flag', async () => {
      mockProcessEnv({ OBSERVABILITY_SENTRY_ENABLED: 'false' });

      const { isSentryEnabled } = await import('../env');

      expect(typeof isSentryEnabled()).toBe('boolean');
      expect(isSentryEnabled()).toBeFalsy();
    });

    test('should read OpenTelemetry enabled flag', async () => {
      mockProcessEnv({ OBSERVABILITY_OTEL_ENABLED: 'true' });

      const { isOtelEnabled } = await import('../env');

      expect(typeof isOtelEnabled()).toBe('boolean');
      expect(isOtelEnabled()).toBeTruthy();
    });

    test('should read OpenTelemetry disabled flag', async () => {
      mockProcessEnv({ OBSERVABILITY_OTEL_ENABLED: 'false' });

      const { isOtelEnabled } = await import('../env');

      expect(typeof isOtelEnabled()).toBe('boolean');
      expect(isOtelEnabled()).toBeFalsy();
    });

    test('should read Logtail enabled flag', async () => {
      mockProcessEnv({ OBSERVABILITY_LOGTAIL_ENABLED: 'true' });

      const { isLogtailEnabled } = await import('../env');

      expect(typeof isLogtailEnabled()).toBe('boolean');
      expect(isLogtailEnabled()).toBeTruthy();
    });

    test('should read Logtail disabled flag', async () => {
      mockProcessEnv({ OBSERVABILITY_LOGTAIL_ENABLED: 'false' });

      const { isLogtailEnabled } = await import('../env');

      expect(typeof isLogtailEnabled()).toBe('boolean');
      expect(isLogtailEnabled()).toBeFalsy();
    });

    test('should read Grafana enabled flag', async () => {
      mockProcessEnv({ OBSERVABILITY_GRAFANA_ENABLED: 'true' });

      const { isGrafanaEnabled } = await import('../env');

      expect(typeof isGrafanaEnabled()).toBe('boolean');
      expect(isGrafanaEnabled()).toBeTruthy();
    });

    test('should read Grafana disabled flag', async () => {
      mockProcessEnv({ OBSERVABILITY_GRAFANA_ENABLED: 'false' });

      const { isGrafanaEnabled } = await import('../env');

      expect(typeof isGrafanaEnabled()).toBe('boolean');
      expect(isGrafanaEnabled()).toBeFalsy();
    });
  });

  describe('configuration presence', () => {
    test('should detect Sentry configuration', async () => {
      mockProcessEnv({
        SENTRY_DSN: 'https://example@sentry.io/123456',
        SENTRY_AUTH_TOKEN: 'token123',
      });

      const { hasSentryConfig } = await import('../env');

      expect(typeof hasSentryConfig()).toBe('boolean');
      expect(hasSentryConfig()).toBeTruthy();
    });

    test('should detect missing Sentry configuration', async () => {
      mockProcessEnv({});

      const { hasSentryConfig } = await import('../env');

      expect(typeof hasSentryConfig()).toBe('boolean');
      expect(hasSentryConfig()).toBeFalsy();
    });

    test('should detect Logtail configuration', async () => {
      mockProcessEnv({
        LOGTAIL_SOURCE_TOKEN: 'logtail_token_123',
      });

      const { hasLogtailConfig } = await import('../env');

      expect(typeof hasLogtailConfig()).toBe('boolean');
      expect(hasLogtailConfig()).toBeTruthy();
    });

    test('should detect missing Logtail configuration', async () => {
      mockProcessEnv({});

      const { hasLogtailConfig } = await import('../env');

      expect(typeof hasLogtailConfig()).toBe('boolean');
      expect(hasLogtailConfig()).toBeFalsy();
    });

    test('should detect Grafana configuration', async () => {
      mockProcessEnv({
        GRAFANA_CLOUD_TOKEN: 'grafana_token_123',
        GRAFANA_CLOUD_URL: 'https://grafana.example.com',
      });

      const { hasGrafanaConfig } = await import('../env');

      expect(typeof hasGrafanaConfig()).toBe('boolean');
      expect(hasGrafanaConfig()).toBeTruthy();
    });

    test('should detect missing Grafana configuration', async () => {
      mockProcessEnv({});

      const { hasGrafanaConfig } = await import('../env');

      expect(typeof hasGrafanaConfig()).toBe('boolean');
      expect(hasGrafanaConfig()).toBeFalsy();
    });

    test('should detect OpenTelemetry configuration', async () => {
      mockProcessEnv({
        OTEL_SERVICE_NAME: 'my-service',
        OTEL_EXPORTER_OTLP_ENDPOINT: 'https://otel.example.com',
      });

      const { hasOtelConfig } = await import('../env');

      expect(typeof hasOtelConfig()).toBe('boolean');
      expect(hasOtelConfig()).toBeTruthy();
    });

    test('should detect missing OpenTelemetry configuration', async () => {
      mockProcessEnv({});

      const { hasOtelConfig } = await import('../env');

      expect(typeof hasOtelConfig()).toBe('boolean');
      expect(hasOtelConfig()).toBeFalsy();
    });
  });

  describe('error handling', () => {
    test('should handle gracefully when environment variables are missing', async () => {
      mockProcessEnv({});

      const { safeEnv } = await import('../env');

      expect(() => safeEnv()).not.toThrow();
    });

    test('should provide safe defaults', async () => {
      mockProcessEnv({});

      const { safeEnv } = await import('../env');
      const env = safeEnv();

      expect(env.NODE_ENV).toBeDefined();
      expect(env.NEXT_PUBLIC_NODE_ENV).toBeDefined();
    });
  });

  describe('type safety', () => {
    test('should return correct types for environment detection', async () => {
      mockProcessEnv({});

      const { isProduction, isDevelopment, isTest, isEdgeRuntime, isNodeRuntime } = await import('../env');

      expect(typeof isProduction()).toBe('boolean');
      expect(typeof isDevelopment()).toBe('boolean');
      expect(typeof isTest()).toBe('boolean');
      expect(typeof isEdgeRuntime()).toBe('boolean');
      expect(typeof isNodeRuntime()).toBe('boolean');
    });

    test('should return correct types for feature flags', async () => {
      mockProcessEnv({});

      const { isConsoleEnabled, isSentryEnabled, isOtelEnabled, isLogtailEnabled, isGrafanaEnabled } = await import('../env');

      expect(typeof isConsoleEnabled()).toBe('boolean');
      expect(typeof isSentryEnabled()).toBe('boolean');
      expect(typeof isOtelEnabled()).toBe('boolean');
      expect(typeof isLogtailEnabled()).toBe('boolean');
      expect(typeof isGrafanaEnabled()).toBe('boolean');
    });

    test('should return correct types for configuration checks', async () => {
      mockProcessEnv({});

      const { hasSentryConfig, hasLogtailConfig, hasGrafanaConfig, hasOtelConfig } = await import('../env');

      expect(typeof hasSentryConfig()).toBe('boolean');
      expect(typeof hasLogtailConfig()).toBe('boolean');
      expect(typeof hasGrafanaConfig()).toBe('boolean');
      expect(typeof hasOtelConfig()).toBe('boolean');
    });
  });
});